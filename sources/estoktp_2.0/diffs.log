50c50
< 
---
> ccccc
62a63
>       integer*8 RPHT_custom_flag(0:6)
88c89
< 
---
>  
97c98,100
< 
---
> c       do i=0,size(RPHT_custom_flag)-1
> c         RPHT_custom_flag(i)=0
> c      end do
106d108
<       igrid_opt_ts=0
108,111c110
< cadl keyword to run GSM for TS localization
<       igsm_opt_ts=0
<       issm_opt_ts=0
< cadl end modified part
---
>       igrid_opt_ts=0
199a199
> c  lc Opt words initialization 
200a201
> c  lc Op. mode read
201a203,211
>       if (WORD .EQ. 'RPHTCUSTOM') then
>          if (WORD2 .EQ. 'TS')    RPHT_custom_flag(0)=1
>          if (WORD2 .EQ. 'REAC1') RPHT_custom_flag(1)=1
>          if (WORD2 .EQ. 'REAC2') RPHT_custom_flag(2)=1
>          if (WORD2 .EQ. 'PROD1') RPHT_custom_flag(3)=1
>          if (WORD2 .EQ. 'PROD2') RPHT_custom_flag(4)=1
>          if (WORD2 .EQ. 'WELLR') RPHT_custom_flag(5)=1
>          if (WORD2 .EQ. 'WELLP') RPHT_custom_flag(6)=1
>       endif
257,259d266
<       if (WORD.EQ.'RESIRCALL_RES') then
<          iresirc = 3      
<       endif
351,360d357
< cadl begin modification
<       if (WORD.EQ.'GSM_OPT_TS') then
<          igsm_opt_ts=1
<          itotcalc=itotcalc+1
<       endif
<       if (WORD.EQ.'SSM_OPT_TS') then
<          issm_opt_ts=1
<          itotcalc=itotcalc+1
<       endif
< cadl end modified part
526a524,529
>          if (WORD2 .EQ. 'TOL')  then 
> c  lc:   TolNum implicitly defined in double precision
>             command1="grep -i 'Symm_ts' data/estoktp.dat | awk
>      $'{print $3}' > Symm_tol.dat "
>             call commrun(command1)
>          end if
544a548
>          if (WORD2.EQ.'INF_HL') ipottype=6
690,733d693
< 
< cadl perform gsm TS search for different types of reaction
<       if (igsm_opt_ts.eq.1) then
<          if (idebug.ge.1) write (6,*) 'starting gsm_opt'
< c         if(iabs.eq.1.or.iadd.eq.1) then
< c            call grid_opt
<          if (iiso.eq.1) then
<             call gsm_opt_iso   
< c         else if (ibeta.eq.1) then
< c            call grid_opt_beta   
< c         else if (ibarr.eq.2) then
< c            call grid_opt_barr_dec   
< c         else if (ibarr.eq.3) then
< c            call grid_opt_barr_rec   
<          else
<             write(7,*) 'supported reacion types for GSM search'
<             write(7,*) 'isomerization'
<             write(7,*) 'make an adeguate selection and restart the code'
<             close(7)
<             stop
<          endif
<       endif
<       if (issm_opt_ts.eq.1) then
<          if (idebug.ge.1) write (6,*) 'starting ssm_opt'
< c         if(iabs.eq.1.or.iadd.eq.1) then
< c            call grid_opt
<          if (iiso.eq.1) then
<             call ssm_opt_iso   
< c         else if (ibeta.eq.1) then
< c            call grid_opt_beta   
< c         else if (ibarr.eq.2) then
< c            call grid_opt_barr_dec   
< c         else if (ibarr.eq.3) then
< c            call grid_opt_barr_rec   
<          else
<             write(7,*) 'supported reacion types for SSM search'
<             write(7,*) 'isomerization'
<             write(7,*) 'make an adeguate selection and restart the code'
<             close(7)
<             stop
<          endif
<       endif
< cadl end modified part
< 
1119c1079
<       character*70 comline1,comline2
---
>       character*300 comline1,comline2
1355,1358c1315,1318
< c print extra info during testing to see where things die
< c nosmp is number of monte carlo sampling points
< c dthresh is threshold for same geometry
< c ethresh is threshold for same energy 
---
> c     print extra info during testing to see where things die
> c     nosmp is number of monte carlo sampling points
> c     dthresh is threshold for same geometry
> c     ethresh is threshold for same energy 
1473a1434,1435
> c lc: G16 implementation  [x]
> c     G16 for LEVEL0 
1500,1501c1462,1463
<          read (21,'(A70)') comline1
<          read (21,'(A70)') comline2
---
>          read (21,'(A300)') comline1
>          read (21,'(A300)') comline2
1588c1550
< c check if reverse index
---
> c check if reverse index_v
1720c1682
<          if(ilev0code.eq.1) then
---
>          if(ilev0code.eq.1.or.ilev0code.eq.3) then
1943c1905
<       character*70 comline1,comline2
---
>       character*300 comline1,comline2
2084a2047
> c lc: G16 implementation  [x]      
2086a2050,2051
>       else if (word2.eq.'G16') then
>          ilev0code=3   
2104,2106c2069,2071
<       if(ilev0code.eq.1)then
<          read (21,'(A70)') comline1
<          read (21,'(A70)') comline2
---
>       if(ilev0code.eq.1.or.ilev0code.eq.3)then
>          read (21,'(A300)') comline1
>          read (21,'(A300)') comline2
2215c2180
<          if(ilev0code.eq.1) then
---
>          if(ilev0code.eq.1.or.ilev0code.eq.3) then
2314c2279
<       character*70 comline1,comline2
---
>       character*300 comline1,comline2
2420a2386
> c lc: G16 implementation  [x]
2422a2389,2390
>       else if (word2.eq.'G16') then
>          ilev0code=3
2440,2442c2408,2410
<       if(ilev0code.eq.1)then
<          read (21,'(A70)') comline1
<          read (21,'(A70)') comline2
---
>       if(ilev0code.eq.1.or.ilev0code.eq.3)then
>          read (21,'(A300)') comline1
>          read (21,'(A300)') comline2
2674c2642
<          if(ilev0code.eq.1) then
---
>          if(ilev0code.eq.1.or.ilev0code.eq.3) then
2748c2716
<       character*70 comline1,comline2
---
>       character*300 comline1,comline2
2841a2810
> c lc: G16 implementation  [x]
2843a2813,2814
>       else if (word2.eq.'G16') then
>          ilev0code=3
2861,2863c2832,2834
<       if(ilev0code.eq.1)then
<          read (21,'(A70)') comline1
<          read (21,'(A70)') comline2
---
>       if(ilev0code.eq.1.or.ilev0code.eq.3)then
>          read (21,'(A300)') comline1
>          read (21,'(A300)') comline2
2935c2906
<          if(ilev0code.eq.1) then
---
>          if(ilev0code.eq.1.or.ilev0code.eq.3) then
3005c2976
<       character*70 comline1,comline2
---
>       character*300 comline1,comline2
3112a3084
> c lc: G16 implementation  [x]      
3114a3087,3088
>       else if (word2.eq.'G16') then
>          ilev0code=3
3132,3134c3106,3108
<       if(ilev0code.eq.1)then
<          read (21,'(A70)') comline1
<          read (21,'(A70)') comline2
---
>       if(ilev0code.eq.1.or.ilev0code.eq.3)then
>          read (21,'(A300)') comline1
>          read (21,'(A300)') comline2
3212d3185
< c      stop
3260,3264d3232
<       if(natom.gt.3)then
<          intcoor(nint-2)=dihb
<          xint(nint-2)=temp_dih
<       endif
< 
3265a3234,3235
>       intcoor(nint-2)=dihb
> 
3266a3237
>       xint(nint-2)=temp_dih
3303c3274
<          if(ilev0code.eq.1) then
---
>          if(ilev0code.eq.1.or.ilev0code.eq.3) then
3390c3361
<       character*70 comline1,comline2
---
>       character*300 comline1,comline2
3531a3503
> c lc: G16 implementation  [x]
3533a3506,3507
>       else if (word2.eq.'G16') then
>          ilev0code=3
3551,3553c3525,3527
<       if(ilev0code.eq.1)then
<          read (21,'(A70)') comline1
<          read (21,'(A70)') comline2
---
>       if(ilev0code.eq.1.or.ilev0code.eq.3)then
>          read (21,'(A300)') comline1
>          read (21,'(A300)') comline2
3671c3645
<          if(ilev0code.eq.1) then
---
>          if(ilev0code.eq.1.or.ilev0code.eq.3) then
3779c3753
<       character*70 comline1,comline2
---
>       character*300 comline1,comline2
3904a3879
> c lc: G16 implementation  [x]      
3906a3882,3883
>       else if (word2.eq.'G16') then
>          ilev0code=3
3924,3926c3901,3903
<       if(ilev0code.eq.1)then
<          read (21,'(A70)') comline1
<          read (21,'(A70)') comline2
---
>       if(ilev0code.eq.1.or.ilev0code.eq.3)then
>          read (21,'(A300)') comline1
>          read (21,'(A300)') comline2
3953c3930
< cc now inizialize the index for dummy atoms
---
> cc now inizialize the index_v for dummy atoms
4091c4068
<       index=0
---
>       index_v=0
4095,4097c4072,4074
<             index=index+1
<             xinti(index)=xint(iatom)
<             intcoori(index)=intcoor(iatom)
---
>             index_v=index_v+1
>             xinti(index_v)=xint(iatom)
>             intcoori(index_v)=intcoor(iatom)
4105c4082
< c      index=0
---
> c      index_v=0
4107,4109c4084,4086
< c         index=index+1
< c         xinti(iatom)=tau(index)
< c         intcoori(iatom)=bislab(index)
---
> c         index_v=index_v+1
> c         xinti(iatom)=tau(index_v)
> c         intcoori(iatom)=bislab(index_v)
4328c4305
<             if(ilev0code.eq.1) then
---
>             if(ilev0code.eq.1.or.ilev0code.eq.3) then
4416c4393
<       character*70 comline1,comline2
---
>       character*300 comline1,comline2
4557a4535
> c lc: G16 implementation  [x]
4559a4538,4539
>       else if (word2.eq.'G16') then
>          ilev0code=3
4577,4579c4557,4559
<       if(ilev0code.eq.1)then
<          read (21,'(A70)') comline1
<          read (21,'(A70)') comline2
---
>       if(ilev0code.eq.1.or.ilev0code.eq.3)then
>          read (21,'(A300)') comline1
>          read (21,'(A300)') comline2
4620c4600
<       if(ilev0code.eq.1) then
---
>       if(ilev0code.eq.1.or.ilev0code.eq.3) then
4698c4678
<       character*70 comline1,comline2
---
>       character*300 comline1,comline2
4904a4885
> c lc: G16 implementation  [x]
4906a4888,4889
>       else if (word2.eq.'G16') then
>          ilev0code=3
4924,4926c4907,4909
<       if(ilev0code.eq.1)then
<          read (21,'(A70)') comline1
<          read (21,'(A70)') comline2
---
>       if(ilev0code.eq.1.or.ilev0code.eq.3)then
>          read (21,'(A300)') comline1
>          read (21,'(A300)') comline2
5012c4995
<       index=0
---
>       index_v=0
5022,5025c5005,5008
<          index=index+1
<          xint(index)=xinti(iatom)
<          intcoor(index)=intcoori(iatom)
<          write (6,*) 'intcoor, xint ',intcoor(index),xint(index)
---
>          index_v=index_v+1
>          xint(index_v)=xinti(iatom)
>          intcoor(index_v)=intcoori(iatom)
>          write (6,*) 'intcoor, xint ',intcoor(index_v),xint(index_v)
5086,5087c5069,5070
<                   xinti(index)=0.
<                   intcoori(index)=''
---
>                   xinti(index_v)=0.
>                   intcoori(index_v)=''
5089c5072
<                index=0
---
>                index_v=0
5093,5095c5076,5078
<                      index=index+1
<                      xinti(index)=xint(iatom)
<                      intcoori(index)=intcoor(iatom)
---
>                      index_v=index_v+1
>                      xinti(index_v)=xint(iatom)
>                      intcoori(index_v)=intcoor(iatom)
5104c5087
<                index=0
---
>                index_v=0
5106,5108c5089,5091
<                   index=index+1
<                   xinti(iatom)=tau(index)
<                   intcoori(iatom)=bislab(index)
---
>                   index_v=index_v+1
>                   xinti(iatom)=tau(index_v)
>                   intcoori(iatom)=bislab(index_v)
5126c5109
<             if(ilev0code.eq.1) then
---
>             if(ilev0code.eq.1.or.ilev0code.eq.3) then
5526,5527c5509,5510
<       character*70 comline1,comline2
<       character*70 comline3,comline4
---
>       character*300 comline1,comline2
>       character*300 comline3,comline4
5532a5516
>       character*480 LongCommand
5541c5525
<       character*30 disb,angb,dihb,angc,dihc,intcoosave
---
>       character*30 disb,angb,dihb,intcoosave
5554a5539,5540
>       character*220 pathtogeoms
>       integer GeomL1Unit
5561a5548
>          write(pathtogeoms,'(A)') 'geoms/reac1_l1.log'
5563a5551
>          write(pathtogeoms,'(A)') 'geoms/reac2_l1.log'
5565a5554
>          write(pathtogeoms,'(A)') 'geoms/prod1_l1.log'
5567a5557
>          write(pathtogeoms,'(A)') 'geoms/prod2_l1.log'
5569a5560
>          write(pathtogeoms,'(A)') 'geoms/tsgta_l1.log'
5571a5563
>          write(pathtogeoms,'(A)') 'geoms/wellr_l1.log'
5573a5566
>          write(pathtogeoms,'(A)') 'geoms/wellp_l1.log'
6190c6183,6184
<          if(word2.eq.'G09'.or.word2.eq.'G16') then
---
> c lc: G16 implementation  [x]
>          if((word2.eq.'G09').or.(word2.eq.'G16'))then
6193,6194c6187,6188
<             read (21,'(A70)') comline1
<             read (21,'(A70)') comline2
---
>             read (21,'(A300)') comline1
>             read (21,'(A300)') comline2
6386,6387c6380,6381
<             read (21,'(A70)') comline1
<             read (21,'(A70)') comline2
---
>             read (21,'(A300)') comline1
>             read (21,'(A300)') comline2
6502d6495
<          ib_froz=0
6515d6507
<             if(word4.eq.'ALL')ib_froz=5
6519,6534d6510
< 
< c check if prod1 has 2 atoms
<             open (unit=67,file='./data/prod1.dat',status='unknown')
<             nat_pr1=0
<             do while (WORD.NE.'NATOM')
<                call LineRead (67)
<                if (WORD.EQ.'END') then
<                 write (7,*) 'in sub lev1 could not open data/prod1.dat'
<                 stop
<                endif
<             enddo
<             read (67,*) nat_pr1
<             close(67)
< c
<             if(nat_pr1.eq.2.and.ib_froz.ne.0)ib_froz=2
< 
6538c6514
< c            write(*,*)'ibindex is',ib_froz
---
> c            write(*,*)'ibindex_v is',ib_froz
6585,6587d6560
<                else if(iatom.eq.ireact+1.and.ireact.gt.3)then
<                   angc=word5
<                   dihc=word7
6644d6616
<                if(word4.eq.'ALL')ib_froz=5
6649c6621
< c            write(*,*)'ibindex is',ibfroz
---
> c            write(*,*)'ibindex_v is',ibfroz
6777,6827d6748
<       else if (ib_froz.eq.5) then
<          ircons=5
<          isub=0
<          xintsave=0.
<          do iint = 1 , ncoord
<             if(intcoor(iint).eq.angb.and.isub.eq.0) then
<                xintsave=xint(ncoord-1)
<                intcoosave=intcoor(ncoord-1)
<                xint(ncoord-1)=xint(iint)
<                intcoor(ncoord-1)=intcoor(iint)
<                xint(iint)=xintsave
<                intcoor(iint)=intcoosave
<                isub=1
<             endif
<          enddo
<          isub=0
<          do iint = 1 , ncoord
<             if(intcoor(iint).eq.dihb.and.isub.eq.0) then
<                xintsave=xint(ncoord-2)
<                intcoosave=intcoor(ncoord-2)
<                xint(ncoord-2)=xint(iint)
<                intcoor(ncoord-2)=intcoor(iint)
<                xint(iint)=xintsave
<                intcoor(iint)=intcoosave
<                isub=1
<             endif
<          enddo
<          isub=0
<          do iint = 1 , ncoord
<             if(intcoor(iint).eq.angc.and.isub.eq.0) then
<                xintsave=xint(ncoord-3)
<                intcoosave=intcoor(ncoord-3)
<                xint(ncoord-3)=xint(iint)
<                intcoor(ncoord-3)=intcoor(iint)
<                xint(iint)=xintsave
<                intcoor(iint)=intcoosave
<                isub=1
<             endif
<          enddo
<          isub=0
<          do iint = 1 , ncoord
<             if(intcoor(iint).eq.dihc.and.isub.eq.0) then
<                xintsave=xint(ncoord-4)
<                intcoosave=intcoor(ncoord-4)
<                xint(ncoord-4)=xint(iint)
<                intcoor(ncoord-4)=intcoor(iint)
<                xint(iint)=xintsave
<                intcoor(iint)=intcoosave
<                isub=1
<             endif
<          enddo
6857d6777
< c      write(*,*)'ib_froz is',ib_froz
6860c6780
<       if(ilev1code.eq.1) then
---
>       if(ilev1code.eq.1.or.ilev1code.eq.3) then
6882,6896d6801
< 
<       if(vtotr.gt.0)then
<          write(7,*)'failed in level1 calculations'
<          write(7,*)'in subroutine level1'
<          write(7,*)'with vtot ',vtotr
<          write(7,*)'terminating code with error'
<          open(unit=99,file='failed',status='unknown')
<          write(99,*)'failed in level1 calculations'
<          write(99,*)'in subroutine level1'
<          write(99,*)'with vtot ',vtotr
<          write(99,*)'terminating code with error'
<          close(99)
<          stop
<       endif
< 
7123a7029,7052
> c  lc READING OF ZPE FROM GAUSSIAN OUTPUT 
> C     1. CHECK IF GAUSSIAN IS USED FOR LEVEL 1 COMPUTATION
> C     2. OPEN THE UNIT WITH THE CORRECT SPECIES OF INTEREST 
> C     3. GREP THE ZPE CORRECTION
> C     4. CONVERT TO KCAL MOL AND STORE IN VARIABLE ZPE 
>          if (ilev1code .eq. 1 .or. ilev1code .eq. 3) then 
>             open(unit=716,file='Anharmonic_frequencies.dat',
>      &       iostat=IAnhCheck,status='old')
>             if (IAnhCheck.ne.0) then 
>                write(LongCommand,'(A)') 
>      &         "grep -iA1 'zero-point correction=' "//
>      &         pathtogeoms//" | awk '{print $3}' > tempzpe.dat"
>             else 
>                write(LongCommand,'(A)') 
>      &         "grep 'ZPE(anh)' "//
>      &         pathtogeoms//" | awk '{print $6}' > tempzpe.dat"
>                close(716,status='delete')
>             end if
>             call commrun(LongCommand)
>             open(unit=711,file='tempzpe.dat')
>             read(711,*) zpe
>             if (IAnhCheck .eq. 0) zpe=zpe*0.00038
>             close(711,status='delete')
>          end if 
7484a7414,7437
> c  lc READING OF ZPE FROM GAUSSIAN OUTPUT 
> C     1. CHECK IF GAUSSIAN IS USED FOR LEVEL 1 COMPUTATION
> C     2. OPEN THE UNIT WITH THE CORRECT SPECIES OF INTEREST 
> C     3. GREP THE ZPE CORRECTION
> C     4. CONVERT TO KCAL MOL AND STORE IN VARIABLE ZPE 
>          if (ilev1code .eq. 1 .or. ilev1code .eq. 3) then 
>             open(unit=716,file='Anharmonic_frequencies.dat',
>      &       iostat=IAnhCheck,status='old')
>             if (IAnhCheck.ne.0) then 
>                write(LongCommand,'(A)') 
>      &         "grep -iA1 'zero-point correction=' "//
>      &         pathtogeoms//" | awk '{print $3}' > tempzpe.dat"
>             else 
>                write(LongCommand,'(A)') 
>      &         "grep 'ZPE(anh)' "//
>      &         pathtogeoms//" | awk '{print $6}' > tempzpe.dat"
>                close(716,status='delete')
>             end if
>             call commrun(LongCommand)
>             open(unit=711,file='tempzpe.dat')
>             read(711,*) zpe
>             if (IAnhCheck .eq. 0) zpe=zpe*(1/0.00038087989)
>             close(711,status='delete')
>          end if 
7749c7702,7703
<       character*70 comline1,comline2,comline3,comline4,comsave1,comsave2
---
>       character*300 comline1,comline2,comline3,comline4,comsave1,
>      $ comsave2
7763a7718
>       character*300 customcommand
7768a7724,7728
> !  lc control section variables for check gaussian output in hindrot geoms
>       character*10 speclabel
> !  lc define two integer variable for iostatus check and test integer for possible
> !     pivot debugging
>       integer TstInt,ReaSts
7772a7733
>       character*150 mstring
7774a7736,7740
>       character*30 LC_At_lab(natommx)
>       character*3000 cstmfmt
>       character*10 atlab1,rval,atlab2,angval,atlab3,diedval,refatom
>       integer*8 RPHT_custom_flag(0:6)
> 
7778c7744
< cc initialize index for only reactant calculation
---
> cc initialize index_v for only reactant calculation
7794a7761
>          speclabel='reac1'
7818a7786
>          speclabel='reac2'
7829,7831c7797,7799
< cs I removed this return - it would be fine for H,O,OH,O2,CH3,HO2 but
< cs will create problems for larger radicals
< cs I don't know if this removal will create other problems
---
> c s I removed this return - it would be fine for H,O,OH,O2,CH3,HO2 but
> c s will create problems for larger radicals
> c s I don't know if this removal will create other problems
7846a7815
>          speclabel='prod1'
7870a7840
>          speclabel='prod2'
7894a7865
>          speclabel='wellr'
7917a7889
>          speclabel='wellr'
7940a7913
>          speclabel='wellp'
7986a7960
>          speclabel='reacs'
8009a7984
>          speclabel='prods'
8032a8008,8088
> c lc debug here:  the debugging will consist in a substitution of
> c                 the numbers used to define the z-matrix connectivity
> c                 with the proper atom label
> c        EXPLANATION
> C        FIRST COPY THE ORIGINAL FILE IN ANOTHER FILE THAT SERVES 
> C        AS TEMPLATE THAN START A READ-WRITE LOOP
> C        IF YOU ARE PROCESSING AN INTERNAL COORDINATE
> C        THEN YOU WILL FIND THE '.' AT THE SECOND
> C        WORD (WHERE THERE SHOULD BE AN ATOM LABEL) 
> C        SO THIS WILL BE WRITE AS IT IS.
> C        ELSE IF YOU DO NOT FIND '.' YOU HAVE TO
> C        PROCESS THE ATOM AND THE Z MATRIX
> C        IN THIS CASE FIRST STORE THE ATOM LABEL
> C        IN ATOM LABEL ARRAY AND THAN PROCESS THE STRING
> C        IF IT FINDS AN INTEGER CONVERT TO THE RELATIVE 
> C        ATOM LABEL IN THE ARRAY
> C        AFTER THAT WRITE THE COORDINATES IN THE NEW TS_OPT_FILE
>          refatom=' '
>          atlab1=' '
>          atlab2=' '
>          atlab3=' '
>          rval=' '
>          angval=' '
>          diedval=' '
>          i_LC_counter=0
>          customcommand='cp ./output/ts_opt.out 
>      &    ./output/ts_opt_template.out'
>          call commrun(customcommand)
>          customcommand=' '
>          open(unit=155,file='./output/ts_opt_template.out',
>      &   action='read',status='old')
>          read(155,'(A)') mstring
>          open (unit=17,file='./output/ts_opt.out'
>      &    ,status='unknown',action='write')
>          write(17,*) trim(mstring)
>          do 
>             read(155,'(A)',iostat=iEoFFl) mstring
>             if (iEoFFl .ne. 0) then 
>                exit 
>             endif  
>                do 
>                   read(mstring,*,iostat=iEoRFl) 
>      &            refatom,atlab1,rval,atlab2,angval,atlab3,diedval 
>                   if (index(atlab1,'.') .gt. 0) then 
>                      write(17,'(A)') trim(mstring)
>                      exit
>                   end if 
>                   i_LC_counter=i_LC_counter+1
>                   read(mstring,*) LC_At_lab(i_LC_counter)
>                   read(atlab1,*,iostat=ReaSts) TstInt
>                   if (ReaSts .eq. 0) then 
>                      atlab1 = LC_At_lab(TstInt)
>                   endif 
>                   read(atlab2,*,iostat=ReaSts) TstInt
>                   if (ReaSts .eq. 0) then 
>                      atlab2 = LC_At_lab(TstInt)
>                   endif 
>                   read(atlab3,*,iostat=ReaSts) TstInt
>                   if (ReaSts .eq. 0) then 
>                      atlab3 = LC_At_lab(TstInt)
>                   endif 
>                   write(17,'(*(A,1x))')
>      &             trim(refatom),trim(atlab1),trim(rval),
>      &             trim(atlab2),trim(angval),trim(atlab3),
>      &             trim(diedval) 
>                   atlab1=' '
>                   atlab2=' '
>                   atlab3=' '
>                   rval=' '
>                   angval=' '
>                   diedval=' '
>                   exit
>                end do 
>          end do
>          close(17)
>          close(155)
>          
> 
> 
> c lc debug stop
>          speclabel='ts'
8204a8261
> c lc: G16 implementation  [x]         
8207,8208c8264,8269
<             read (21,'(A70)') comline1
<             read (21,'(A70)') comline2
---
>             read (21,'(A300)') comline1
>             read (21,'(A300)') comline2
>          else if (word2.eq.'G16') then
>             ilev1code=3
>             read (21,'(A300)') comline1
>             read (21,'(A300)') comline2
8290d8350
<       endif
8291a8352
>       endif
8393d8453
<             if(word4.eq.'ALL')ib_froz=5
8421a8482,8483
> c lc: G16 implementation  [x]
> c     special check on this         
8424,8425c8486,8499
<             read (21,'(A70)') comline1
<             read (21,'(A70)') comline2
---
>             read (21,'(A300)') comline1
>             read (21,'(A300)') comline2
>             if(ispecies.eq.0.or.ispecies.eq.100.or.ispecies.eq.101) then
>                read (21,'(A300)') comline3
>                read (21,'(A300)') comline4
>                if(ispecies.eq.100.or.ispecies.eq.101) then
>                   comline1=comline3
>                   comline2=comline4
>                endif
>             endif
>          else if(word2.eq.'G16') then
>             ilev1code=3
>             read (21,'(A300)') comline1
>             read (21,'(A300)') comline2
8427,8428c8501,8502
<                read (21,'(A70)') comline3
<                read (21,'(A70)') comline4
---
>                read (21,'(A300)') comline3
>                read (21,'(A300)') comline4
8500c8574
<               read (22,'(A70)') comline1
---
>               read (22,'(A300)') comline1
8511c8585
<               read (21,'(A70)') comline1
---
>               read (21,'(A300)') comline1
8633a8708,8724
> c  lc : see lc debug in the next line to understand the following code
> c                read(PivotA(ihind),*,iostat=ReaSts) TstInt
> c                if (ReaSts .eq. 0) then 
> c                   write(99,*) 'Numeric Pivot A is ', PivotA(ihind)
> c                   PivotA(ihind) = atomname(TstInt)
> c                   write(99,*) 'Pivot A is ', PivotA(ihind)
> c                endif 
> c                read(PivotB(ihind),*,iostat=ReaSts) TstInt
> c                if (ReaSts .eq. 0) then 
> c c                  PivotB(ihind) = atomname(TstInt)
> c c c              toremovestart
> c                    write(99,*) PivotB(ihind)
> c                    write(99,*) atomconn(natomt1+1)
> c                    write(99,*) atomconn(natomt1+2)
> c                    write(99,*) atomname(isite)
> c c              toremoveend
> c               endif 
8637c8728,8738
< 
---
> c  lc debug :  up to now the variables pivotB and A are treated as
> c              they contains an atom label since each comparison is
> c              made with atomconn for example that contains the atom labels
> c              but for atom abstraction, if the selected hindered is the one
> c              defined by the dummy atom in a gaussian procedure, each atom 
> c              label is defined as a number pointing the the atom position in
> c              Z-matrix. 
> 
> c              Possible debug:   check if and integer is contained in the PivotA
> c                                or PivotB variable and in case treat this as a
> c                                pointer to atomname vector i-element. 
8641d8741
< 
8650,8655c8750,8767
<                if(pivotB(ihind).eq.atomconn(natomt1+1))then
<                   pivotB(ihind)=atomname(isite)
<                endif
<                if(pivotB(ihind).eq.atomconn(natomt1+2))then
<                   pivotB(ihind)=atomname(isite)
<                endif
---
>                write(99,*) PivotB(ihind),atomconn(natomt1+1)
>                write(99,*) natomt1+1
> c lc TEST FIXING START
>                if (hindlab(ihind).eq.'BABS1') then
>                   if (index(pivotB(ihind),'X').gt.0) then
>                      pivotB(ihind)=atomname(jsite)
> c                     pivotA(ihind)=atomname(isite)
>                   end if  
> 
>                else  
> c lc TEST FIXING END
>                   if(pivotB(ihind).eq.atomconn(natomt1+1))then
>                      pivotB(ihind)=atomname(isite)
>                   endif
>                   if(pivotB(ihind).eq.atomconn(natomt1+2))then
>                      pivotB(ihind)=atomname(isite)
>                   endif
>                end if
8678a8791
> 
8704d8816
< 
8717a8830,8843
> cc lc debug unit 
>       open(unit=778,file='tempdebug.dat')
> 
>       write(778,"(50('-'))") 
>       write(778,'(A)') 'atom name vector'
>       write(778,'(A,/)') atomname(1:5)
>       write(778,'(A,/)') 'isite is', atomname(isite)
>       write(778,'(A,/)') 'jsite is', atomname(jsite)
>       write(778,"(50('-'))")
>       write(778,'(A)') 'atom conn vector'
>       write(778,'(A,/)') atomconn(1:5)
>       write(778,*) 'natomt is ',natomt
>       write(778,*) PivotA(1),'  ',PivotB(1)
>       write(778,"(50('-'))")
8724d8849
< 
8726d8850
< 
8727a8852,8854
>             write(778,*) 'atomname ',atomname(iatom)
>             write(778,*) 'pivotA(ihind) ',pivotA(ihind)
>             write(778,*) 'pivotB(ihind) ',pivotB(ihind)
8731a8859
>          write(778,*) 'itop_ind(iatom,ihind)  ',itop_ind(iatom,ihind)
8733d8860
< 
8743a8871
> c             write(778,*) 'icounter is  ',icounter
8786d8913
< 
8788d8914
< 
8793a8920,8921
>                write(778,*) 'iatom in this case is ',iatom
>                write(778,*) 'the atomin this case is ',atomname(iatom)
8796a8925,8926
>                write(778,*) 'iatom in this case is ',iatom
>                write(778,*) 'the atomin this case is ',atomname(iatom)
8806c8936
<            write (7,*)'dicheck1 is ',dicheck1(ihind),'top is',
---
>            write (7,*)'dicheck1 is ',dicheck1(ihind),' top is',
8814c8944
< cc now inizialize the index for dummy atoms
---
> cc now inizialize the index_v for dummy atoms
8893c9023
<          index=0
---
>          index_v=0
8901,8902c9031,9032
< c         write(*,*)'at index 1',ihr_at1
< c         write(*,*)'at index 2',ihr_at2
---
> c         write(*,*)'at index_v 1',ihr_at1
> c         write(*,*)'at index_v 2',ihr_at2
8909,8911c9039,9041
<             index=index+1
<             xintt(index)=xinti(icoo)
<             intcoort(index)=intcoori(icoo)
---
>             index_v=index_v+1
>             xintt(index_v)=xinti(icoo)
>             intcoort(index_v)=intcoori(icoo)
8923c9053
<          index=0
---
>          index_v=0
8929,8930c9059,9060
< c         write(*,*)'at index 1',ihr_at1
< c         write(*,*)'at index 2',ihr_at2
---
> c         write(*,*)'at index_v 1',ihr_at1
> c         write(*,*)'at index_v 2',ihr_at2
8936,8938c9066,9068
<             index=index+1
<             xintt(index)=xinti(icoo)
<             intcoort(index)=intcoori(icoo)
---
>             index_v=index_v+1
>             xintt(index_v)=xinti(icoo)
>             intcoort(index_v)=intcoori(icoo)
8978c9108
<          index=0
---
>          index_v=0
8992,8995c9122,9125
<             index=index+1
<             xint(index)=xinti(iatom)
<             intcoor(index)=intcoori(iatom)
<             write (16,*) 'intcoor, xint ',intcoor(index),xint(index)
---
>             index_v=index_v+1
>             xint(index_v)=xinti(iatom)
>             intcoor(index_v)=intcoori(iatom)
>             write (16,*) 'intcoor, xint ',intcoor(index_v),xint(index_v)
9032,9035c9162
<          if(ib_froz.eq.5) then
<             ircons=ircons+4
<          endif
< 
---
> c         stop 'debug stop'
9038d9164
< 
9056c9182,9209
<             if(ilev1code.eq.1) then
---
>             if(ilev1code.eq.1.or.ilev1code.eq.3) then
> !  lc    CHECK FOR PREVIOUS HINDERED ROTORS SCANNED
> !        FIRST CHECK ASSIGN TO CUSTOMCOMMAND VARIABLE THE FILENAME
> !        THE 2006 FORMAT IS A TAIL OF THE HINDERED ROTOR FILE TO
> !        GREP THE NORMAL TERMINATION STRING
> !        THE 2007 IS AN ECHO OF THE FILENAME 
> !        THE 2008 IS THE FILENAME COMPOSITION
>             open(unit=208,file='HindNormalCheck.log',
>      &       iostat=icheck,status='old') 
>             if (icheck .eq. 0) close(208,status='delete')
>             customcommand=' '
>             write(customcommand,2008) ismp,trim(speclabel)
>             open(unit=208,file=customcommand,iostat=iEoFFl,
>      &           status='old')
>             if (iEoFFl.eq.0) then 
>                write(customcommand,2011) ismp,trim(speclabel)
>                customcommand=
>      &         trim(customcommand)//' >> HindNormalCheck.log'
>                call commrun(customcommand)
>                write(customcommand,2007) ismp,trim(speclabel)
>                customcommand=
>      &         trim(customcommand)//' >> HindNormalCheck.log'
>                call commrun(customcommand)
>                close(208,status='keep')
>             end if 
> !        IF NORMAL TERMINATION IS OBTAINED COPY THIS TO THE GEOM.LOG FILE
> !        AND GENERATE A FILE THAT CONTAINS THE INSTRUCTION FOR G09FOPT
> !        TO SKIP THE GAUSSIAN CALL AND PROCESS THIS FILE
9061a9215,9225
> !        BE SURE TO REMOVE THE INSTRUCTION FILE 
> 
>                customcommand='rm HindNormalCheck.log'
>                call commrun(customcommand)
>                customcommand='mkdir -p hindered_rotors_gaussian_files'
>                call commrun(customcommand) 
>                write(customcommand,2005) ismp,trim(speclabel)
>                call commrun(customcommand)
>                write(customcommand,2009) ismp,trim(speclabel)
>                call commrun(customcommand)
>                customcommand=' '
9063,9064c9227
<                numproc=numprochl
<          
---
>                numproc=numprochl         
9124c9287
<                   index=0
---
>                   index_v=0
9129,9133c9292,9296
<                      index=index+1
< c                     write(16,*)'index intcoort(index)',index,
< c     $                           intcoort(index)
<                      xintt(index)=xint_save(icoo)
<                      intcoort(index)=intcoor(icoo)
---
>                      index_v=index_v+1
> c                     write(16,*)'index_v intcoort(index_v)',index_v,
> c     $                           intcoort(index_v)
>                      xintt(index_v)=xint_save(icoo)
>                      intcoort(index_v)=intcoor(icoo)
9380a9544
>          call ModRPHt(ispecies,RPHT_custom_flag)
9387a9552
>          call ModRPHt(ispecies,RPHT_custom_flag)
9394a9560
>          call ModRPHt(ispecies,RPHT_custom_flag)
9401a9568
>          call ModRPHt(ispecies,RPHT_custom_flag)
9408a9576
>          call ModRPHt(ispecies,RPHT_custom_flag)
9415a9584
>          call ModRPHt(ispecies,RPHT_custom_flag)
9438a9608
>          call ModRPHt(ispecies,RPHT_custom_flag)
9643a9814,9827
>  2005    format ("cp geom.log hindered_rotors_gaussian_files/hind_"
>      & ,I0,"_",A,".log")
>  2006    format ("tail -1 hindered_rotors_gaussian_files/hind_"
>      & ,I0,"_",A,".log")
>  2011    format (                                                
>      &  "grep -i 'normal termination' 
>      &   hindered_rotors_gaussian_files/hind_"
>      & ,I0,"_",A,".log")
>  2007    format ("echo hindered_rotors_gaussian_files/hind_"
>      & ,I0,"_",A,".log")
>  2008    format ("hindered_rotors_gaussian_files/hind_"
>      & ,I0,"_",A,".log")
>  2009    format ("cp tmp.chk hindered_rotors_gaussian_files/hind_"
>      & ,I0,"_",A,".chk")
9681c9865
<      $ abcrot(ndim),xintt(3*natommx),xint_save(3*natommx),
---
>      $ abcrot(ndim),xintt(3*natommx),xint_save(3*natommx),freq(nmdmx),
9702,9704c9886,9888
<       character*70 comline1,comline2,comline3,comline4,comsave1
<       character*70 comline5,comline6,comlineref1
<       character*70 comlineref2,comsave2
---
>       character*300 comline1,comline2,comline3,comline4,comsave1
>       character*300 comline5,comline6,comlineref1
>       character*300 comlineref2,comsave2
9740a9925
>       integer*8 RPHT_custom_flag(0:6)
9808,9810c9993,9995
< cs I removed this return - it would be fine for H,O,OH,O2,CH3,HO2 but
< cs will create problems for larger radicals
< cs I don't know if this removal will create other problems
---
> c s I removed this return - it would be fine for H,O,OH,O2,CH3,HO2 but
> c s will create problems for larger radicals
> c s I don't know if this removal will create other problems
10461,10462c10646,10651
<             read (21,'(A70)') comline1
<             read (21,'(A70)') comline2
---
>             read (21,'(A300)') comline1
>             read (21,'(A300)') comline2
>          else if (word2.eq.'G16') then 
>             ilev1code=3
>             read (21,'(A300)') comline1
>             read (21,'(A300)') comline2
10485c10674
<             if(ilev1code.eq.1)then
---
>             if(ilev1code.eq.1.or.ilev1code.eq.3)then
10489,10490c10678,10679
< c            read (21,'(A70)') comline5
< c            read (21,'(A70)') comline6
---
> c            read (21,'(A300)') comline5
> c            read (21,'(A300)') comline6
10668,10669c10857,10879
<             read (21,'(A70)') comline1
<             read (21,'(A70)') comline2
---
>             read (21,'(A300)') comline1
>             read (21,'(A300)') comline2
>             if(ispecies.eq.0) then
>                read (21,'(A300)') comline3
>                read (21,'(A300)') comline4
>             endif
>             call LineRead (21)
>             if(word.eq.'MHR_FREQS') then
> c               read (21,'(A300)') comline5
> c               read (21,'(A300)') comline6
>                imhrfr=1
> c               write(*,*)'imhrf is ',imhrfr
> c               stop
>                if(ilev1code.eq.1.or.ilev1code.eq.3)then
>                  call comline56_g09(ispecies,comline1,comline2,
>      +           comline5,comline6)
>                endif
>             endif
> c  lc :  New g16 implementation start
>          else if(word2.eq.'G16') then
>             ilev1code=3
>             read (21,'(A300)') comline1
>             read (21,'(A300)') comline2
10671,10672c10881,10882
<                read (21,'(A70)') comline3
<                read (21,'(A70)') comline4
---
>                read (21,'(A300)') comline3
>                read (21,'(A300)') comline4
10676,10677c10886,10887
< c               read (21,'(A70)') comline5
< c               read (21,'(A70)') comline6
---
> c               read (21,'(A300)') comline5
> c               read (21,'(A300)') comline6
10681,10683c10891,10893
<                if(ilev1code.eq.1)then
<                  call comline56_g09(ispecies,comline1,comline2,comline5,
<      +                comline6)
---
>                if(ilev1code.eq.1.or.ilev1code.eq.3)then
>                  call comline56_g09(ispecies,comline1,comline2,
>      +           comline5,comline6)
10685a10896
> c  lc :  New g16 implementation end
10836c11047
<          index=0
---
>          index_v=0
10839,10841c11050,11052
<             index=index+1
<             xint_int(index)=xinti(iatom)
<             intcoor_int(index)=intcoori(iatom)
---
>             index_v=index_v+1
>             xint_int(index_v)=xinti(iatom)
>             intcoor_int(index_v)=intcoori(iatom)
10860c11071
<          index=0
---
>          index_v=0
10863,10865c11074,11076
<             index=index+1
<             xint(index)=xint_int(iatom)
<             intcoor(index)=intcoor_int(iatom)
---
>             index_v=index_v+1
>             xint(index_v)=xint_int(iatom)
>             intcoor(index_v)=intcoor_int(iatom)
10904c11115
<             if(ilev1code.eq.1) then
---
>             if(ilev1code.eq.1.or.ilev1code.eq.3) then
10945c11156
<                   index=0
---
>                   index_v=0
10950,10954c11161,11165
<                      index=index+1
< c     write(16,*)'index intcoort(index)',index,
< c     $                           intcoort(index)
<                      xintt(index)=xint_save(icoo)
<                      intcoort(index)=intcoor(icoo)
---
>                      index_v=index_v+1
> c     write(16,*)'index_v intcoort(index_v)',index_v,
> c     $                           intcoort(index_v)
>                      xintt(index_v)=xint_save(icoo)
>                      intcoort(index_v)=intcoor(icoo)
11015c11226
<                if(ilev1code.eq.1) then
---
>                if(ilev1code.eq.1.or.ilev1code.eq.3) then
11065a11277
>                   call ModRPHt(ispecies,RPHT_custom_flag)
11072a11285
>                   call ModRPHt(ispecies,RPHT_custom_flag)
11079a11293
>                   call ModRPHt(ispecies,RPHT_custom_flag)
11086a11301
>                   call ModRPHt(ispecies,RPHT_custom_flag)
11093a11309
>                   call ModRPHt(ispecies,RPHT_custom_flag)
11100a11317
>                   call ModRPHt(ispecies,RPHT_custom_flag)
11121a11339
>                   call ModRPHt(ispecies,RPHT_custom_flag)
11271c11489
<          index=0
---
>          index_v=0
11274,11276c11492,11494
<             index=index+1
<             xint_int(index)=xinti(iatom)
<             intcoor_int(index)=intcoori(iatom)
---
>             index_v=index_v+1
>             xint_int(index_v)=xinti(iatom)
>             intcoor_int(index_v)=intcoori(iatom)
11294c11512
<          index=0
---
>          index_v=0
11297,11299c11515,11517
<             index=index+1
<             xint(index)=xint_int(iatom)
<             intcoor(index)=intcoor_int(iatom)
---
>             index_v=index_v+1
>             xint(index_v)=xint_int(iatom)
>             intcoor(index_v)=intcoor_int(iatom)
11365c11583
<                if(ilev1code.eq.1) then
---
>                if(ilev1code.eq.1.or.ilev1code.eq.3) then
11418c11636
<                      index=0
---
>                      index_v=0
11423,11427c11641,11645
<                         index=index+1
< c     write(16,*)'index intcoort(index)',index,
< c     $                           intcoort(index)
<                         xintt(index)=xint_save(icoo)
<                         intcoort(index)=intcoor(icoo)
---
>                         index_v=index_v+1
> c     write(16,*)'index_v intcoort(index_v)',index_v,
> c     $                           intcoort(index_v)
>                         xintt(index_v)=xint_save(icoo)
>                         intcoort(index_v)=intcoor(icoo)
11489c11707
<                   if(ilev1code.eq.1) then
---
>                   if(ilev1code.eq.1.or.ilev1code.eq.3) then
11538c11756
<      $ hrdata4proj.dat '
---
>      $                     hrdata4proj.dat '
11541c11759,11760
<      $ geom.log ',natom
---
>      $                        geom.log ',natom
>                   call ModRPHt(ispecies,RPHT_custom_flag)
11549a11769
>                   call ModRPHt(ispecies,RPHT_custom_flag)
11556a11777
>                   call ModRPHt(ispecies,RPHT_custom_flag)
11563a11785
>                   call ModRPHt(ispecies,RPHT_custom_flag)
11570a11793
>                   call ModRPHt(ispecies,RPHT_custom_flag)
11577a11801
>                   call ModRPHt(ispecies,RPHT_custom_flag)
11598a11823
>                   call ModRPHt(ispecies,RPHT_custom_flag)
11766c11991
<          index=0
---
>          index_v=0
11769,11771c11994,11996
<             index=index+1
<             xint_int(index)=xinti(iatom)
<             intcoor_int(index)=intcoori(iatom)
---
>             index_v=index_v+1
>             xint_int(index_v)=xinti(iatom)
>             intcoor_int(index_v)=intcoori(iatom)
11789c12014
<          index=0
---
>          index_v=0
11792,11794c12017,12019
<             index=index+1
<             xint_int2(index)=xint_int(iatom)
<             intcoor_int2(index)=intcoor_int(iatom)
---
>             index_v=index_v+1
>             xint_int2(index_v)=xint_int(iatom)
>             intcoor_int2(index_v)=intcoor_int(iatom)
11812c12037
<          index=0
---
>          index_v=0
11815,11817c12040,12042
<             index=index+1
<             xint(index)=xint_int2(iatom)
<             intcoor(index)=intcoor_int2(iatom)
---
>             index_v=index_v+1
>             xint(index_v)=xint_int2(iatom)
>             intcoor(index_v)=intcoor_int2(iatom)
11899c12124
<                   if(ilev1code.eq.1) then
---
>                   if(ilev1code.eq.1.or.ilev1code.eq.3) then
11953c12178
<                      index=0
---
>                      index_v=0
11958,11962c12183,12187
<                         index=index+1
< c     write(16,*)'index intcoort(index)',index,
< c     $                           intcoort(index)
<                         xintt(index)=xint_save(icoo)
<                         intcoort(index)=intcoor(icoo)
---
>                         index_v=index_v+1
> c     write(16,*)'index_v intcoort(index_v)',index_v,
> c     $                           intcoort(index_v)
>                         xintt(index_v)=xint_save(icoo)
>                         intcoort(index_v)=intcoor(icoo)
12068c12293
<                   if(ilev1code.eq.1) then
---
>                   if(ilev1code.eq.1.or.ilev1code.eq.3) then
12123a12349
>                   call ModRPHt(ispecies,RPHT_custom_flag)
12130a12357
>                   call ModRPHt(ispecies,RPHT_custom_flag)
12137a12365
>                   call ModRPHt(ispecies,RPHT_custom_flag)
12144a12373
>                   call ModRPHt(ispecies,RPHT_custom_flag)
12151a12381
>                   call ModRPHt(ispecies,RPHT_custom_flag)
12158a12389
>                   call ModRPHt(ispecies,RPHT_custom_flag)
12179a12411
>                   call ModRPHt(ispecies,RPHT_custom_flag)
12792a13025
>       dimension idummy(natommx)
12803c13036
<       character*70 comline1,comline2,comline3,comline4,comsave1,comsave2
---
>       character*300 comline1,comline2,comline3,comline4,comsave1,comsave2
13110a13344
> c lc: G16 implementation  [x]       
13113,13114c13347,13352
<          read (21,'(A70)') comline1
<          read (21,'(A70)') comline2
---
>          read (21,'(A300)') comline1
>          read (21,'(A300)') comline2
>       else if(word2.eq.'G16')then
>          ilev1code=3
>          read (21,'(A300)') comline1
>          read (21,'(A300)') comline2
13146c13384,13396
<       write(15,*)'Tolerance 0.07'
---
> c  lc: open file for check symmetry factor. 
> c      if the file is present then read the 
> c      read the symmetry factor. Remember to 
> c      delete the file after the reading
>       open(unit=177,file='Symm_tol.dat',
>      $status='old',iostat=ios)
>       if (ios .eq. 0) then
>          read(177,*) TolNum
>          write(15,*)'Tolerance ',TolNum
>          close(177,status='delete')
>       else
>          write(15,*)'Tolerance 0.07'
>       end if
13292c13542
<                if(ilev1code.eq.1) then
---
>                if(ilev1code.eq.1.or.ilev1code.eq.3) then
13539a13790
>       dimension idummy(natommx)
13542,13543c13793,13794
<       character*70 comline1,comline2,comline3,comline4
< c      character*70 comline3,comline4
---
>       character*300 comline1,comline2,comline3,comline4
> c      character*300 comline3,comline4
13572a13824
>       integer*8 RPHT_custom_flag(0:6)
13618a13871
> c lc: G16 implementation  [x] 
13621,13624c13874,13883
<          read (21,'(A70)') comline1
<          read (21,'(A70)') comline2
<          read (21,'(A70)') comline3
<          read (21,'(A70)') comline4
---
>          read (21,'(A300)') comline1
>          read (21,'(A300)') comline2
>          read (21,'(A300)') comline3
>          read (21,'(A300)') comline4
>       else if(word2.eq.'G16') then
>          ilev0code=3
>          read (21,'(A300)') comline1
>          read (21,'(A300)') comline2
>          read (21,'(A300)') comline3
>          read (21,'(A300)') comline4
13865c14124
<       if(ilev0code.eq.1) then
---
>       if(ilev0code.eq.1.or.ilev0code.eq.3) then
14054c14313
<       write(333,*)'Npointsint:                 5 '
---
>       write(333,*)'Npointsint:                 0 '
14065c14324
<       write(333,*)'reduced_mass                -10.0'
---
>       write(333,*)'reduced_mass                1.0'
14099c14358
<          write(133,*)'reduced_mass                -10.0'
---
>          write(133,*)'reduced_mass                1.0'
14157c14416
<          write (333,*) 'gradient'       
---
>          write (333,*) 'gradient'      
14204a14464
>          call ModRPHt(0,RPHT_custom_flag)
14282,14284c14542
< cc         write(133,*)'reduced_mass                1.0'
< cc setting red mass to -1 lets the code compute its red mass
<          write(133,*)'reduced_mass                -10.0'
---
>          write(133,*)'reduced_mass                1.0'
14313c14571,14572
<          write (133,*) 'gradient'       
---
>          write (133,*) 'gradient'  
>          write(*,*) 'the number of atom is ',natom     
14325c14584
<   
---
>          call ModRPHt(0,RPHT_custom_flag)
14500c14759
<             index=0
---
>             index_v=0
14502,14504c14761,14763
< c               index=1+(j-1)*istep
<                index=nhrcc_points(j)
< c               write(*,*)'index is',index
---
> c               index_v=1+(j-1)*istep
>                index_v=nhrcc_points(j)
> c               write(*,*)'index_v is',index_v
14508,14510c14767,14769
<                write(99,*)atgeom_me(isite,index)
<                write(99,*)atgeom_me(jsite,index)
<                write(99,*)atgeom_me(natom1+1,index)
---
>                write(99,*)atgeom_me(isite,index_v)
>                write(99,*)atgeom_me(jsite,index_v)
>                write(99,*)atgeom_me(natom1+1,index_v)
14530c14789
<                write (108,1306)index
---
>                write (108,1306)index_v
14551c14810,14811
<                   read(107,*)(rotpot_ir(ik,index,ir),ik=1,numpot_ir(ir))
---
>                   read(107,*)
>      &             (rotpot_ir(ik,index_v,ir),ik=1,numpot_ir(ir))
14559c14819
<             index=0
---
>             index_v=0
14561,14562c14821,14822
<                index=nhrcc_points(j)
< c               write(*,*)'test index is',index
---
>                index_v=nhrcc_points(j)
> c               write(*,*)'test index_v is',index_v
14565c14825
<                write(99,*)atgeom_me(isite,index)
---
>                write(99,*)atgeom_me(isite,index_v)
14567c14827
<                   write(99,*)atgeom_me(natom1+1,index)
---
>                   write(99,*)atgeom_me(natom1+1,index_v)
14569c14829
<                   write(99,*)atgeom_me(ireact,index)
---
>                   write(99,*)atgeom_me(ireact,index_v)
14592c14852
<                write (108,9306)index
---
>                write (108,9306)index_v
14613c14873,14874
<                   read(107,*)(rotpot_ir(ik,index,ir),ik=1,numpot_ir(ir))
---
>                   read(107,*)
>      &             (rotpot_ir(ik,index_v,ir),ik=1,numpot_ir(ir))
14629,14631c14890,14892
<                index=nhrcc_points(1)
< c               index=1
<                indexp1=0
---
>                index_v=nhrcc_points(1)
> c               index_v=1
>                index_vp1=0
14634c14895
< c                  indexp1=index+istep
---
> c                  index_vp1=index_v+istep
14638,14639c14899,14900
<                      index=nhrcc_points(ij)
<                      indexp1=nhrcc_points(ij+1)
---
>                      index_v=nhrcc_points(ij)
>                      index_vp1=nhrcc_points(ij+1)
14644,14646c14905,14907
<                         rotpot_ir(ik,j,ir)= rotpot_ir(ik,index,ir)+
<      $                       (rotpot_ir(ik,indexp1,ir)
<      $                       -rotpot_ir(ik,index,ir))*
---
>                         rotpot_ir(ik,j,ir)= rotpot_ir(ik,index_v,ir)+
>      $                       (rotpot_ir(ik,index_vp1,ir)
>      $                       -rotpot_ir(ik,index_v,ir))*
14658,14659c14919,14920
< c                     index=index+istep
< c                     index=nhrcc_points(j+1)
---
> c                     index_v=index_v+istep
> c                     index_v=nhrcc_points(j+1)
14935c15196
<       if(iresirc.eq.2.or.iresirc.eq.3) then
---
>       if(iresirc.eq.2) then
14945,14959d15205
<          intres=0
<          if(iresirc.eq.3)then
<             open (unit=107, file='./irc_files/hl_en_int.dat', 
<      $           status='unknown')
<             read(107,*)intres
<             do ij=1,intres                  
<                read (107,*)cjunk,rc_ene_hl(ij)
<             enddo
<             close(107)
<            write(96,*)'restarting HL IRC energy scan from point ',intres
<            write(7,*)
<            write(7,*)'restarting HL IRC energy scan from point ',intres
<            write(7,*)
<          endif
< 
15072c15318
< 
---
>       call ModRPHt(0,RPHT_custom_flag)
15383,15384c15629
< c     +                 (freqproj(j,inumpoints),j=1,nfreqw)
<      +                 (freqproj(j,inumpoints),j=1,nfreq)
---
>      +                 (freqproj(j,inumpoints),j=1,nfreqw)
15392,15393c15637
< c     +                    (freqintproj(j,inumpoints),j=1,nfreqw)
<      +                    (freqintproj(j,inumpoints),j=1,nfreq)
---
>      +                    (freqintproj(j,inumpoints),j=1,nfreqw)
15426c15670
<       character*70 comline1,comline2
---
>       character*300 comline1,comline2
15439c15683
<      $ abcrot(ndim) 
---
>      $ abcrot(ndim),freq(3*natommx)
15440a15685,15687
>       dimension tau(ntaumx)
>       dimension tauopt(ntaumx)
> 
15448a15696,15699
>       character*70 Hl_iter_file
>       
> c  lc new   New variable definition
>       integer IterFlag
15449a15701,15702
>       
>       
15451c15704,15706
< 
---
> c     lc new   New variable initialization
>       IterFlag=-1
>       Hl_iter_file='hl_molpro.dat_iter_'
15461a15717
>          Hl_iter_file=Hl_iter_file(1:19)//'reac1'
15463a15720
>          Hl_iter_file=Hl_iter_file(1:19)//'reac2'
15465a15723
>          Hl_iter_file=Hl_iter_file(1:19)//'prod1'
15467a15726
>          Hl_iter_file=Hl_iter_file(1:19)//'prod2'
15469a15729
>          Hl_iter_file=Hl_iter_file(1:19)//'ts'
15505,15506c15765,15789
<          ilev1code=2
<          commandcopy='cp -f ./data/hl_molpro.dat ./hl_molpro.dat'       
---
>          ilev1code=2 
> c  lc new   here introduce the iterative keyword START
>          command1="grep -i 'hlevel molpro' ./data/theory.dat 
>      &    > LC_tmp.dat"
>          call commrun(command1)
>          command1='grep -ic iterative_molpro LC_tmp.dat 
>      &   > LC_iterative_flag.dat '
>          call commrun(command1)
>          open(unit=967,file='LC_iterative_flag.dat')
>          read(967,*) IterFlag
>          close(967) 
> c  lc new END 
> 
> c  lc new   here, copy different hl_molpro.dat file if 
> c           the iterative keyword is active 
>          commandcopy='cp -f ./data/hl_molpro.dat ./hl_molpro.dat'    
>          if (IterFlag .ne. 0) then
>             write(commandcopy,9111) Hl_iter_file
>  9111    format('cp -f ./data/',A50,1x,'./hl_molpro.dat') 
>          end if
> c  lc new END
> 
> c lc: G16 implementation  [x] 
> c to correct the index_v ilev1code=3 
> c special check on this           
15510c15793
<          ilev1code=1
---
>          ilev1code=3
15680,15681c15963,15964
<          if(ibarr.gt.1.and.ilev1code.eq.2)then
<             command1='egrep CBSEN  hl_logs/ts_molpro.out > en.dat'
---
>          if(ibarr.gt.1.and.ilevcode.eq.2)then
>             command1='egrep -w CBSEN hl_logs/ts_molpro.out > en.dat'
15686c15969
<             command1='egrep CBSEN  ../100/hl_logs/ts_molpro.out > 
---
>             command1='egrep -w CBSEN ../100/hl_logs/ts_molpro.out > 
15692c15975,15977
<          else if (ibarr.gt.1.and.ilev1code.eq.1)then
---
> c todo check results
>          else if (ibarr.gt.1.and.
>      $    (ilevcode.eq.1.or.ilevcode.eq.3))then
15719,15720d16003
<          write(66,*)'ts energy',ts_en_l1
<          write(66,*)'prod energy',prod_en_l1
16123,16124c16406,16407
< 
<          else if (code_name.eq.'G09')then   
---
> c lc: G16 implementation  [x] 
>          else if ((code_name.eq.'G09').or.(code_name.eq.'G16'))then   
16134,16135c16417,16418
<             read (21,'(A70)') comline1
<             read (21,'(A70)') comline2
---
>             read (21,'(A300)') comline1
>             read (21,'(A300)') comline2
16138,16143d16420
< c            write(67,*) comline1
< c            write(67,*) comline2
< c            write(67,*)
< c            write(67,*)' gaussian geom'
< c            write(67,*)
< c            write (67,*) icharge,ispin
16146d16422
< c               write (67,*)atomlabel(iatom)
16148d16423
< c            write(67,*)
16398c16673,16674
<                   if(word2.eq.'G09')then
---
> c lc: G16 implementation  [x] 
>                   if((word2.eq.'G09').or.(word2.eq.'G16'))then
16405c16681
<                  read (22,'(A100)') comline3
---
>                  read (22,'(A300)') comline3
16415c16691
<                  read (21,'(A100)') comline3
---
>                  read (21,'(A300)') comline3
16451c16727,16728
<          else if (code_name.eq.'G09')then   
---
> c lc: G16 implementation  [x] 
>          else if ((code_name.eq.'G09').or.(code_name.eq.'G16'))then
16461,16462c16738,16739
<             read (21,'(A70)') comline1
<             read (21,'(A70)') comline2
---
>             read (21,'(A300)') comline1
>             read (21,'(A300)') comline2
16708c16985
<       if (code_name.eq.'G09')then   
---
>       if ((code_name.eq.'G09').or.(code_name.eq.'G16'))then   
18536c18813
<          index=0
---
>          index_v=0
18539,18541c18816,18818
<                index=index+1
<                gelec12(index)=gelec1(j)*gelec2(i)
<                eelec12(index)=eelec1(j)+eelec2(i)
---
>                index_v=index_v+1
>                gelec12(index_v)=gelec1(j)*gelec2(i)
>                eelec12(index_v)=eelec1(j)+eelec2(i)
18808c19085
<             index=0
---
>             index_v=0
18811,18813c19088,19090
<                   index=index+1
<                   gelec12(index)=gelec1(j)*gelec2(i)
<                   eelec12(index)=eelec1(j)+eelec2(i)
---
>                   index_v=index_v+1
>                   gelec12(index_v)=gelec1(j)*gelec2(i)
>                   eelec12(index_v)=eelec1(j)+eelec2(i)
19144a19422,19425
>       integer TSUnit,StatuFlag
>       character*240 iostring
>       logical dummycustom
>       real xbond,xangle,xdihed
19164a19446,19466
>       dummycustom=.false. 
> 
>       open (newunit=TSUnit,file='./data/ts.dat',status='old')
>       do 
>          read(TSUnit,'(A)',iostat=StatuFlag) iostring
>          if ( index(iostring,'dummycustom') .gt. 0 )  then 
>                dummycustom= .true. 
> c            write(99,1900) 'X111 ',isite,xbond,jsite,xangle,ksite,xdihed
> 1900          format(a4,4x,i4,1x,3(f4.2,2x,i4,1x))
> 1899          format(a4,4x,i4,1x,2(f4.2,2x,i4,1x))
>             do 
>                read(TSUnit,'(A)') iostring
>                if (iostring(1:1) .eq. '!') cycle 
>                read(iostring,*) xbond,xangle,xdihed
>                exit
>             end do 
>             exit
>          end if 
>       end do
>       close(TSUnit,status='keep')
> 
19216c19518
< cc modified intcoor vector index
---
> cc modified intcoor vector index_v
19255c19557
< cc modified intcoor vector index
---
> cc modified intcoor vector index_v
19268a19571,19573
>             if (dummycustom) then 
>                write(99,1900) 'X111 ',isite,xbond,jsite,xangle,ksite,xdihed
>             else 
19271a19577
>             end if 
19277a19584,19586
>             if (dummycustom) then
>                write(99,1899) 'X111 ',isite,xbond,jsite,xangle
>             else 
19279a19589
>             end if 
19285a19596,19598
>             if (dummycustom) then 
>                write(99,1900) 'X111 ',isite,xbond,jsite,xangle,ksite,xdihed
>             else 
19288a19602
>             end if 
19456c19770
< cc modified intcoor vector index
---
> cc modified intcoor vector index_v
19721c20035
< cc now check for dummy atoms and update ireact ixyz ij ik indexes
---
> cc now check for dummy atoms and update ireact ixyz ij ik index_ves
19775c20089
< cc modified intcoor vector index
---
> cc modified intcoor vector index_v
20003c20317
<       index=0
---
>       index_v=0
20006,20008c20320,20322
<             index=index+1
<             intcoort(index)=intcoor(icoord)
<             xintt(index)=xinti(icoord)
---
>             index_v=index_v+1
>             intcoort(index_v)=intcoor(icoord)
>             xintt(index_v)=xinti(icoord)
20114c20428
< cc modified intcoor vector index
---
> cc modified intcoor vector index_v
20182c20496
<       index=0
---
>       index_v=0
20185,20187c20499,20501
<             index=index+1
<             xintt(index) = xinti(icoord)
<             intcoort(index) = intcoor(icoord)
---
>             index_v=index_v+1
>             xintt(index_v) = xinti(icoord)
>             intcoort(index_v) = intcoor(icoord)
20203,20207c20517,20520
<       do icoord = 1 , natom1p
<          write(6,*)icoord, xinti(icoord)
<          write(6,*)icoord, intcoor(icoord)
<       enddo
< c      stop
---
> c      do icoord = 1 , natom1p
> c         write(6,*)icoord, xinti(icoord)
> c         write(6,*)icoord, intcoor(icoord)
> c      enddo
20527,20528d20839
<       nclose_ss=0
<       nopen_ss=0
20569,20570c20880
< c         if(nlps.gt.1.and.j.gt.numopentot)nstatew=nstates
<          if(nlps.gt.0.and.j.gt.numopentot)nstatew=nstates
---
>          if(nlps.gt.1.and.j.gt.numopentot)nstatew=nstates
20572,20575d20881
<          if(j.eq.1)then
<             nclose_ss=nclose
<             nopen_ss=nopen
<          endif
20583,20588d20888
<       if(ispin.eq.1)then
<          write(101,*)'commands for spin splitting'
<          write(101,990)nclose,nopen,neltot,mspin+2,nstatew
<          write(101,991)nclose_ss,nopen_ss,neltot,mspin+2,1
<          write(101,992)neltot,mspin+2
<       endif
20590d20889
< 
20600,20602d20898
<  991  format('{multi;closed,',I2,';occ,',I2,';wf,',I3,',1,',I1',;state,'
<      $ ,I1';maxiter,40;canorb,2101.2}')
<  992  format('{rhf;wf,',I3,',1,',I1';start,2101.2}')
21221c21517
< cc here I inizialize indexes to check if int coor is an angle or a dihedral
---
> cc here I inizialize index_ves to check if int coor is an angle or a dihedral
22845c23141,23145
<       dimension freqintproj(3*natommx)
---
>       dimension freqintproj(3*natommx),freq(nmdmx),tau(ntaumx)
>       dimension tauopt(ntaumx)
>       dimension xint(3*natommx)
>       dimension abcrot(ndim)
>       dimension coord(natommx,ndim)
22858,22859c23158,23159
<       character*70 comline1,comline2
<       character*70 comline3,comline4
---
>       character*300 comline1,comline2
>       character*300 comline3,comline4
22860a23161,23163
>       character*20 bislab(ntaumx)
>       character*30 intcoor(3*natommx)
>       integer*8 RPHT_custom_flag(0:6)
23005a23309
> c lc: G16 implementation  [x] 
23008,23009c23312,23318
<             read (21,'(A70)') comline1
<             read (21,'(A70)') comline2
---
>             read (21,'(A300)') comline1
>             read (21,'(A300)') comline2
>             iGOpMod=1
>          else if(word2.eq.'G16')then
>             ilev1code=3
>             read (21,'(A300)') comline1
>             read (21,'(A300)') comline2
23041c23350
<          read (99,'(A70)') comline4
---
>          read (99,'(A300)') comline4
23052c23361
<          if(ilev1code.eq.1) then
---
>          if(ilev1code.eq.1.or.ilev1code.eq.3) then
23089c23398
<       write(133,*)'reduced_mass                 1.0'
---
>       write(133,*)'reduced_mass                1.0'
23199c23508
< 
---
>       call ModRPHt(0,RPHT_custom_flag)
23301,23302c23610
<       dimension potco_hl(npespointsmx),pot_tot(npespointsmx)
<       dimension potzpe(npespointsmx)
---
>       dimension potco_hl(npespointsmx)
23317c23625
<       character*70 comline1,comline2
---
>       character*300 comline1,comline2
23565a23874,23875
>       command1="sed -ie 's/Gb/ /I' temp.tmp"
>       call commrun(command1)
23584a23895,23923
> c  lc :  DEBUG NEW
> c        if the iGOpMod variable is setted to one skips the read
> c        and set the active space variables to meaningless values
> c        since the script moltogau will ignore the multireference
> c        part and will generate a gaussian DFT calculation input
>       open(unit=977,file='GCntrFile.dat',status='old',action='read'
>      $ ,iostat=i_status)
>       read(977,'(I1)') iGOpMod
>       close(977)
> c  lc :  The second condition is necessary since
> c        in future hybrid mode are setted for 
> c        different values of iGOpMod 
> c        if the iGOpMod is set to 2 or to 3 
> c        it must skip the read of as_vrc 
> c        'AS_VRC specify the active space to use
> c        for hlevel_ts computation
>       if ((iGOpMod.eq.0 ).or.(iGOpMod.eq.1) ) then
>          do while (WORD.NE.'AS_VRC')
>             call LineRead (13)
>             if (WORD.EQ.'END') then
>                write(7,*) 'active space and orbitals for VRC'
>                write(7,*) 'must be described in theory.dat'
>                write(7,*) 'If you are interested in full gaussian
>      & procedure you must create a file called'
>                write(7,*) 'GCntrFile.dat'
>                write(7,*) 'And write 2 or 3'          
>                stop
>             endif
>          enddo
23586,23597c23925,23932
<       do while (WORD.NE.'AS_VRC')
<          call LineRead (13)
<          if (WORD.EQ.'END') then
<             write(7,*) 'active space and orbitals for VRC'
<             write(7,*) 'must be described in theory.dat'
<             stop
<          endif
<       enddo
< 
<       read (13,*) cjunk,nbonds
<       read (13,*) cjunk,nlps
<       read (13,*) cjunk,nstates
---
>          read (13,*) cjunk,nbonds
>          read (13,*) cjunk,nlps
>          read (13,*) cjunk,nstates
>       else 
>          nbonds=1
>          nlps=1
>          nstates=1
>       end if
23599c23934
< 
---
>  
23624c23959
<       read (12,'(A70)') comline1
---
>       read (12,'(A300)') comline1
23642c23977
<          read (15,'(A70)') comline2
---
>          read (15,'(A300)') comline2
23651c23986
<          open(unit=151,file='../100/me_files/potcorr_inf.me',
---
>          open(unit=15,file='../100/me_files/potcorr_inf.me',
23653,23654c23988,23989
<          read(151,*)vinfen
<          close(151)
---
>          read(15,*)vinfen
>          close(15)
23656,23660c23991
<          if(nstates.eq.1)then
<             write(11,*)'   molpro_energy = energy +',abs(vinfen)
<          else
<             write(11,*)'   molpro_energy = energy(1) +',abs(vinfen)
<          endif
---
>          write(11,*)'   molpro_energy = energy +',abs(vinfen)
23765,23766c24096,24117
< 
< 
---
> c ------ some comments on this --------
> c lc: first dependency ts.dat 
> c     isite, the reaction site on the first fragment  
> c     jsite and ksite define the connectivity of ibond atom 
> c     for example 
> c     isite ji ki
> c     1     2  3
> c     Defines the first atom (respect reactant) as the
> c     reaction site. 
> c     ibond 
> c     5  
> c     Defines that the 5th atom is bond to isite, 1 and 
> c     The z-matrix will correspond to
> c     5 1 2 3
> c     Now lets define the z-matrix for the other 2 atoms
> c     of the second fragment, we will have
> c     ijkbond
> c     6  7
> c     So the Z-matrix will be 
> c     6 5 1 2 for the second fragment atom 6
> c     7 5 6 1 for the second fragment atom 7
> c ------ some comments on this --------
23797a24149,24151
> c  lc :  maybe to correct, in the manual
> c        the keyword in the manual is
> c        npivpoints and not pivpoints 
23812a24167,24169
> c  lc :  if addpivtot equals 0 then reads
> c        the next line? and read word2 that 
> c        in ts.dat for C2H6 is set to 2
23825a24183,24184
> c  lc :  if iaddpivtot is set equal to 0 
> c        the loop does not start
23899d24257
<          rewind(25)
23955d24312
<          rewind(25)
23974d24330
<       rewind(25)
24063,24064c24419
<       write(*,*)'npiv1 is',npiv1
<       write(*,*)'ipivtot1 is',ipivtot1
---
> c      write(*,*)'npiv1 is',npiv1
24080,24083d24434
<       write(*,*)'npiv2 is',npiv2
<       write(*,*)'ipivtot2 is',ipivtot2
< c      stop
< 
24136a24488
> 
24151,24155c24503,24506
<          if(natom1.gt.2)then
<              call zmat_to_xyz(xsitep1,ysitep1,zsitep1,cooxp1(nrat1(j)),
<      $           cooyp1(nrat1(j)),coozp1(nrat1(j)),cooxp1(nrat2(j)),
<      $           cooyp1(nrat2(j)),coozp1(nrat2(j)),cooxp1(nrat3(j)),
<      $           cooyp1(nrat3(j)),coozp1(nrat3(j)),dist,ang,dih)
---
>          call zmat_to_xyz(xsitep1,ysitep1,zsitep1,cooxp1(nrat1(j)),
>      $        cooyp1(nrat1(j)),coozp1(nrat1(j)),cooxp1(nrat2(j)),
>      $        cooyp1(nrat2(j)),coozp1(nrat2(j)),cooxp1(nrat3(j)),
>      $        cooyp1(nrat3(j)),coozp1(nrat3(j)),dist,ang,dih)
24157,24158c24508,24509
<            write(7,*)''
<            write(7,*)'additional piv coords: ',j,xsitep1,ysitep1,zsitep1
---
>          write(7,*)''
>          write(7,*)'additional piv coords: ',j,xsitep1,ysitep1,zsitep1
24164,24192c24515,24517
<             xsitep1=xsitep1-cooxp1(nrat1(j))
<             ysitep1=ysitep1-cooyp1(nrat1(j))
<             zsitep1=zsitep1-coozp1(nrat1(j))
< 
<             rho1=sqrt(xsitep1**2+ysitep1**2+zsitep1**2)
<             if(abs(xsitep1).lt.0.01.and.abs(ysitep1).lt.0.01)then
<                theta(iang)=0.01
<             else if (abs(xsitep1).lt.0.01.and.abs(ysitep1).gt.0.1)then
<                theta(iang)=3.14159/2.*180./3.14159
<             else
<                theta(iang)=(atan2(ysitep1,xsitep1))*180./3.14159
< c         theta1=(acos(xsitep1/sqrt(xsitep1**2+ysitep1**2)))*180./3.14159
<             endif
<          
<             if(abs(zsitep1).lt.0.01)then
<                phi(iang)=3.14159/2.*180./3.14159
<             else
<              phi(iang)=(atan2(sqrt(xsitep1**2+ysitep1**2),zsitep1))*180.
<      +           /3.14159
<             endif
<          write(7,*)'pivot j polar coords are: ,',j,theta(iang),phi(iang)
<          else if (natom1.eq.2)then
<             write(7,*)'requested second pivo point on frag 1'
< c            xsitep1=-rts*cos(aabs1)
< c            ysitep1=-rts*sin(aabs1)
< c            zsitep1=0.
< c            xsitep1=xsitep1-xsite1
< c            ysitep1=ysitep1-ysite1
< c            zsitep1=zsitep1-zsite1
---
>          xsitep1=xsitep1-cooxp1(nrat1(j))
>          ysitep1=ysitep1-cooyp1(nrat1(j))
>          zsitep1=zsitep1-coozp1(nrat1(j))
24193a24519,24526
>          rho1=sqrt(xsitep1**2+ysitep1**2+zsitep1**2)
>          if(abs(xsitep1).lt.0.01.and.abs(ysitep1).lt.0.01)then
>             theta(iang)=0.01
>          else if (abs(xsitep1).lt.0.01.and.abs(ysitep1).gt.0.1)then
>             theta(iang)=3.14159/2.*180./3.14159
>          else
>             theta(iang)=(atan2(ysitep1,xsitep1))*180./3.14159
> c         theta1=(acos(xsitep1/sqrt(xsitep1**2+ysitep1**2)))*180./3.14159
24195d24527
<       enddo
24197c24529,24538
< cc if natom2>1 we compute the pivot atom coords also for fragment 2
---
>          if(abs(zsitep1).lt.0.01)then
>             phi(iang)=3.14159/2.*180./3.14159
>          else
>             phi(iang)=(atan2(sqrt(xsitep1**2+ysitep1**2),zsitep1))*180.
>      +           /3.14159
>          endif
>          write(7,*)'pivot j polar coords are: ,',j,theta(iang),phi(iang)
>       enddo
> 
> cc if natom2>1 we compute the pivot atom coords also for fragment 2
24344d24684
<       iv=0
24347,24352c24687
<          iv=iv+1
<          if(ip.lt.10)then
<             write(11,302)ip,xsite1,id,iv,ip,ysite1,id,iv,ip,zsite1
<          else
<             write(11,3021)ip,xsite1,id,iv,ip,ysite1,id,iv,ip,zsite1
<          endif
---
>          write(11,302)ip,xsite1,id,iv,ip,ysite1,id,iv,ip,zsite1
24354,24371c24689
<          if(ip.lt.10)then
<             write(11,313)ip,xsite1,id,iv,ip,ysite1,id,iv,ip,zsite1
<          else
<             write(11,3131)ip,xsite1,id,iv,ip,ysite1,id,iv,ip,zsite1
<          endif
< c         write(*,*)'iaddpiv1 is',iaddpiv1
< c         stop
<          do j=1,iaddpiv1
<             ip=ip+1
<             iv=iv+1
<             write(11,322)ip,cooxp1(nrat1(j)),id,iv,ip,cooyp1(nrat1(j))
<      +            ,id,iv,ip,coozp1(nrat1(j))
<             ip=ip+1
<             write(11,323)ip,cooxp1(nrat1(j)),id,iv,ip,cooyp1(nrat1(j))
<      +            ,id,iv,ip,coozp1(nrat1(j))
<          enddo
<          write(11,*)
< 
---
>          write(11,303)ip,xsite1,id,iv,ip,ysite1,id,iv,ip,zsite1
24378,24382c24696
<          if(ip.lt.10)then
<             write(11,301)ip,xsite1,ip,ysite1,ip,zsite1
<          else
<             write(11,3011)ip,xsite1,ip,ysite1,ip,zsite1
<          endif
---
>          write(11,301)ip,xsite1,ip,ysite1,ip,zsite1
24384c24698
<       else if (natom1.gt.2.and.npiv1.ne.1)then
---
>       else if (natom1.gt.2.and.npiv1.eq.0)then
24387,24391c24701
<          if(ip.lt.10)then
<           write(11,304)ip,xsite1,id,iv,iv,ip,ysite1,id,iv,iv,ip,zsite1,
<      + id,iv
<          else
<           write(11,3041)ip,xsite1,id,iv,iv,ip,ysite1,id,iv,iv,ip,zsite1,
---
>          write(11,304)ip,xsite1,id,iv,iv,ip,ysite1,id,iv,iv,ip,zsite1,
24393d24702
<          endif
24395d24703
<          if(ip.lt.10)then
24398,24401d24705
<          else
<          write(11,3051)ip,xsite1,id,iv,iv,ip,ysite1,id,iv,iv,ip,zsite1,
<      + id,iv
<          endif
24405d24708
<             if(ip.lt.10)then
24408,24411d24710
<             else
<           write(11,3041)ip,cooxp1(nrat1(j)),id,iv,iv,ip,cooyp1(nrat1(j))
<      +           ,id,iv,iv,ip,coozp1(nrat1(j)),id,iv
<             endif
24413d24711
<             if(ip.lt.10)then
24416,24419d24713
<             else
<           write(11,3051)ip,cooxp1(nrat1(j)),id,iv,iv,ip,cooyp1(nrat1(j))
<      +           ,id,iv,iv,ip,coozp1(nrat1(j)),id,iv
<             endif
24424,24428c24718
<          if(ip.lt.10)then
<             write(11,301)ip,xsite1,ip,ysite1,ip,zsite1
<          else
<             write(11,3011)ip,xsite1,ip,ysite1,ip,zsite1
<          endif
---
>          write(11,301)ip,xsite1,ip,ysite1,ip,zsite1
24432d24721
<             if(ip.lt.10)then
24435,24438d24723
<             else
<           write(11,3041)ip,cooxp1(nrat1(j)),id,iv,iv,ip,cooyp1(nrat1(j))
<      +           ,id,iv,iv,ip,coozp1(nrat1(j)),id,iv
<             endif
24440d24724
<             if(ip.lt.10)then
24443,24446d24726
<             else
<           write(11,3051)ip,cooxp1(nrat1(j)),id,iv,iv,ip,cooyp1(nrat1(j))
<      +           ,id,iv,iv,ip,coozp1(nrat1(j)),id,iv
<             endif
24465,24469c24745
<          if(ip.lt.10)then
<             write(11,301)ip,xc,ip,yc,ip,zc
<          else
<             write(11,3011)ip,xc,ip,yc,ip,zc
<          endif
---
>          write(11,301)ip,xc,ip,yc,ip,zc
24519c24795
<          write(11,*)'PivotPoints     ',ipivtot2
---
>          write(11,*)'PivotPoints     2'
24522,24579c24798
<          ip=ip+1
<          write(11,301)ip,xc,ip,yc,ip,zc
< c         write(11,301)ip,xsite4,ip,ysite4,ip,zsite4
<          write(11,*)
<          write(11,*)'# interpointal distances'
<          write(11,*)'#'
<          write(11,*)
<          write(11,*)'Distances'
<          write(11,*)
<          if(ipivtot1.eq.1)then
<             write(11,*)'r11 = r'
<          else 
<             do j=1,ipivtot1
<                if(j.lt.10)then
<                   write(11,401)j
<                else
<                   write(11,501)j
<                endif
< c            write(11,*)'r11 = r-d1'
< c            write(11,*)'r21 = r-d1'
<             enddo
<          endif
< 
<          write(11,*)
<          write(11,*)'Conditions 0'
<          write(11,*)
<          numcycles=0
<          if(ipivtot1.eq.1)then
<             numcycles=1
<          else
<             numcycles=2+ipivtot1/2
< c            numcycles=3
<          endif
<          write(11,*)'Cycles ',numcycles
<          write(11,*)
<          write(11,*)'r = (8.5, 8.25, 8.0, 7.5, 7.0, 6.5, 6.0, 5.75, 5.5, 
<      + 5.0, 4.75, 4.5)'
<          if(ipivtot1.gt.1)then         
<             write(11,*)'d1 = (0.01, 0.15, 0.3)'
< c            if(iaddpivtot.gt.0)then
< c               do j=1,iaddpivtot
< c                  write(11,406)j+1
< c               enddo
< c            endif
<             if(ipivtot1.gt.2)then
<                do j=1,ipivtot1/2
< c     write(11,402)j,phi(j)
< c     write(11,403)j,theta(j)
<                   write(11,403)j,aabs1
< c                  write(11,403)j,-aabs1
<                enddo
<             else
<                   write(11,403)j,aabs1
<             endif
<          endif
<          write(11,*)
<          write(11,*)'EndSurface'
<          write(11,*)
---
> cc to be continued     
24584d24802
<          ip=ip+1
24586,24590c24804,24805
<             if(ip.lt.10)then
<                write(11,301)ip,xsite4,ip,ysite4,ip,zsite4
<             else
<                write(11,3011)ip,xsite4,ip,ysite4,ip,zsite4
<             endif
---
>             ip=ip+1
>             write(11,301)ip,xsite4,ip,ysite4,ip,zsite4
24594d24808
<                if(ip.lt.10)then
24598,24602d24811
<                else
<                write(11,3041)ip,cooxp2(nrat1(j)),id,iv,iv,ip,
<      +              cooyp2(nrat1(j))
<      +           ,id,iv,iv,ip,coozp2(nrat1(j)),id,iv
<                endif
24604d24812
<                if(ip.lt.10)then
24608,24612d24815
<                else
<                write(11,3051)ip,cooxp2(nrat1(j)),id,iv,iv,ip,
<      +              cooyp2(nrat1(j))
<      +           ,id,iv,iv,ip,coozp2(nrat1(j)),id,iv
<                endif
24618,24622c24821
<                if(ip.lt.10)then
<                   write(11,302)ip,xsite4,id,iv,ip,ysite4,id,iv,ip,zsite4
<                else
<                   write(11,3021)ip,xsite4,id,iv,ip,ysite4,id,iv,ip,zsite4
<                endif
---
>                write(11,302)ip,xsite4,id,iv,ip,ysite4,id,iv,ip,zsite4
24624,24628c24823
<                if(ip.lt.10)then
<                   write(11,303)ip,xsite4,id,iv,ip,ysite4,id,iv,ip,zsite4
<                else
<                   write(11,3031)ip,xsite4,id,iv,ip,ysite4,id,iv,ip,zsite4
<                endif
---
>                write(11,303)ip,xsite4,id,iv,ip,ysite4,id,iv,ip,zsite4
24632d24826
<                if(ip.lt.10)then
24635,24638d24828
<                else
<                write(11,3041)ip,xsite4,id,iv,iv,ip,ysite4,id,iv,iv,ip,
<      +              zsite4,id,iv
<                endif
24640d24829
<                if(ip.lt.10)then
24643,24646d24831
<                else
<                write(11,3051)ip,xsite4,id,iv,iv,ip,ysite4,id,iv,iv,ip,
<      +              zsite4,id,iv
<                endif
24650d24834
<                   if(ip.lt.10)then
24654,24658d24837
<                   else
<                   write(11,3041)ip,cooxp2(nrat1(j)),id,iv,iv,ip,
<      +              cooyp2(nrat1(j))
<      +           ,id,iv,iv,ip,coozp2(nrat1(j)),id,iv
<                   endif
24660d24838
<                   if(ip.lt.10)then
24664,24668d24841
<                   else
<                   write(11,3051)ip,cooxp2(nrat1(j)),id,iv,iv,ip,
<      +              cooyp2(nrat1(j))
<      +           ,id,iv,iv,ip,coozp2(nrat1(j)),id,iv
<                   endif
24752c24925
<             write(11,*)'d1 = (0.01, 0.15, 0.3)'
---
>             write(11,*)'d1 = (0.01, 0.3, 0.5)'
24763c24936
<             write(11,*)'d1 = (0.01, 0.15, 0.3)'
---
>             write(11,*)'d1 = (0.01, 0.3, 0.5)'
24774,24775c24947,24948
<             write(11,*)'d1 = (0.01, 0.15, 0.3)'
<             write(11,*)'d2 = (0.01, 0.15, 0.3)'
---
>             write(11,*)'d1 = (0.01, 0.3, 0.5)'
>             write(11,*)'d2 = (0.01, 0.3, 0.5)'
24794c24967
<             write(11,*)'d1 = (0.01, 0.15, 0.3)'
---
>             write(11,*)'d1 = (0.01, 0.3, 0.5)'
24801,24802c24974,24975
<             write(11,*)'d1 = (0.01, 0.15, 0.3)'
<             write(11,*)'d2 = (0.01, 0.15, 0.3)'
---
>             write(11,*)'d1 = (0.01, 0.3, 0.5)'
>             write(11,*)'d2 = (0.01, 0.3, 0.5)'
24827,24828c25000
<       write(14,602)
<       write(14,601)
---
>       write(14,*)'Point Geom corr HL corr (kcal/mol'
24854,24860d25025
<          write(99,106)cfile
<          rewind(99)
<          read(99,'(A40)')filename
<          open(unit=15,file=filename,status='unknown')
<          read(15,*)potzpe(j)
<          close(15)
<          rewind(99)
24876,24879d25040
<       filename='../100/me_files/ts_zpe.me'
<       open(unit=15,file=filename,status='unknown')
<       read(15,*)potzpe(npoints+1)
<       close(15)
24889d25049
<          pot_tot(j)=(pothlr(j)-pothlr(npoints+1))*627.5
24892,24895c25052
<          pzpe=0.
<          pzpe=(potzpe(j)- potzpe(npoints+1))*627.5
<          write(14,603)rinp(j),potco_geom(j),potco_hl(j),pot_tot(j),pzpe
< c     +(potzpe(j)- potzpe(npoints+1))*627.5
---
>          write(14,*)rinp(j),potco_geom(j),potco_hl(j)
24933d25089
<  106  format('../',A8,'/me_files/ts_zpe.me')
24968d25123
<  3011 format('x',I2,' = ',F5.2,' y',I2,' = ',F5.2,' z',I2,' = ',F5.2,1X)
24971,24972d25125
<  3021 format('x',I2,' = ',F5.2,' +d',I1,'*cos(a',I1,') y',I2,' = '
<      + ,F5.2,'+d',I1,'*sin(a',I1,') z',I2,' = ',F5.2,1X)
24975,24984d25127
<  3031 format('x',I2,' = ',F5.2,' -d',I1,'*cos(a',I1,') y',I2,' = '
<      + ,F5.2,'-d',I1,'*sin(a',I1,') z',I2,' = ',F5.2,1X)
<  313  format('x',I1,' = ',F5.2,' +d',I1,'*cos(a',I1,') y',I1,' = '
<      + ,F5.2,'-d',I1,'*sin(a',I1,') z',I1,' = ',F5.2,1X)
<  322  format('x',I1,' = ',F5.2,' -d',I1,'*cos(a',I1,') y',I1,' = '
<      + ,F5.2,'+d',I1,'*sin(a',I1,') z',I1,' = ',F5.2,1X)
<  323  format('x',I1,' = ',F5.2,' -d',I1,'*cos(a',I1,') y',I1,' = '
<      + ,F5.2,'-d',I1,'*sin(a',I1,') z',I1,' = ',F5.2,1X)
<  3131 format('x',I2,' = ',F5.2,' +d',I1,'*cos(a',I1,') y',I2,' = '
<      + ,F5.2,'-d',I1,'*sin(a',I1,') z',I2,' = ',F5.2,1X)
24989,24991d25131
<  3041 format('x',I2,' = ',F5.2,' +d',I1,'*sin(p',I1,')*cos(a',I1,') y'
<      + ,I2,' = ',F5.2,'+d',I1,'*sin(p',I1,')*sin(a',I1,') z',I2,' = ',
<      + F5.2,' +d',I1,'*cos(p',I1,')',1x)
24996,24999d25135
<  3051 format('x',I2,' = ',F5.2,' -d',I1,'*sin(p',I1,')*cos(a',I1,') y'
<      + ,I2,' = ',F5.2,
<      + '-d',I1,'*sin(p',I1,')*sin(a',I1,') z',I2,' = ',F5.2,' -d'
<      + ,I1,'*cos(p',I1,')')
25009,25014d25144
<  601  format(2X,'Distance',4X,'Geom Corr',4X,'HL Corr',3X,'Potential',
<      +  3X,'ZPE')
<  602  format(2X,'All energies in kcal/mol with respect to fragments')
<  603  format(1X,F7.2,7X,F7.4,5X,F7.4,2X,F7.2,2X,F7.2)
< c      write(14,601)' Point  Geom corr HL corr (kcal/mol)'
< 
25071,25074c25201,25204
< c      character*70 comline1,comline2
< c      character*70 comline3,comline4
<       character*70 comline1,comline2
<       character*70 comline3,comline4
---
> c      character*300 comline1,comline2
> c      character*300 comline3,comline4
>       character*300 comline1,comline2
>       character*300 comline3,comline4
25088a25219
>       integer*8 RPHT_custom_flag(0:6)
25231,25234d25361
< cc initialization of algorithm type
< 
<       ilocmin=0
< 
25503a25631,25632
> c lc: G16 implementation  [] 
> c check the correctness of the actual implementation
25505,25508c25634,25637
<          read (21,'(A70)') comline1
<          read (21,'(A70)') comline2
<          read (21,'(A70)') comline3
<          read (21,'(A70)') comline4
---
>          read (21,'(A300)') comline1
>          read (21,'(A300)') comline2
>          read (21,'(A300)') comline3
>          read (21,'(A300)') comline4
25557,25576d25685
<       if(word4.eq.'DUMMY')then
< C         if(ilevcode.eq.2)then
< C            write(7,*)'guess and molpro are incompatible keywords'
< C            write(7,*)'change selection and restart'
< C            stop
< C         endif
<          ilocmin=1
<          iguess2=2
<          write(7,*)
<          write(7,*)'assuming PES2 and PES1 as equal'
<          write(7,*)'skipping calculations for PES2'
<          write(7,*)
<          write(31,*)
<          write(31,*)'assuming PES2 and PES1 as equal'
<          write(31,*)'skipping calculations for PES2'
<          write(31,*)
<          command1='cp -f data/tmp_na2.chk .'
<          call commrun(command1)
<       endif
< 
25591c25700
< c      read (21,'(A70)') comline1
---
> c      read (21,'(A300)') comline1
25605c25714
< c      read (21,'(A70)') comline1
---
> c      read (21,'(A300)') comline1
25756,25771c25865,25868
<             write(15,*)ilevcode
<             if(ilevcode.eq.1.or.ilevcode.eq.3)then
<                write(15,*)comline1
<                write(15,*)comline2
<                write(15,*)comline3
<                write(15,*)comline4
<             else if (ilevcode.eq.2)then
<                write(15,*)'./data/natst_pes1_molpro.dat'
<                write(15,*)'./data/natst_pes2_molpro.dat'
<                write(15,*)'key1'
<                write(15,*)'key2'
<             else
<                write(7,*)'it seems the code choice is not defined'
<                write(7,*)'please check the input'
<                write(7,*)stop
<             endif
---
>             write(15,*)comline1
>             write(15,*)comline2
>             write(15,*)comline3
>             write(15,*)comline4
25784,25788c25881
<             if(ilocmin.eq.0)then
<                call na_tst_opt()
<             else
<                call con_min_opt()
<             endif
---
>             call na_tst_opt()
25815,25834c25908,25911
<             write(15,*)ilevcode
<             if(ilevcode.eq.1.or.ilevcode.eq.3)then
<                write(15,*)comline1
<                write(15,*)comline2
<                write(15,*)comline3
<                write(15,*)comline4
<             else if (ilevcode.eq.2)then
<                write(15,*)'./data/natst_pes1_molpro.dat'
<                write(15,*)'./data/natst_pes2_molpro.dat'
<                write(15,*)'key1'
<                write(15,*)'key2'
<             else
<                write(7,*)'it seems the code choice is not defined'
<                write(7,*)'please check the input'
<                write(7,*)stop
<             endif
< c            write(15,*)comline1
< c            write(15,*)comline2
< c            write(15,*)comline3
< c            write(15,*)comline4
---
>             write(15,*)comline1
>             write(15,*)comline2
>             write(15,*)comline3
>             write(15,*)comline4
25850,25854c25927
<             if(ilocmin.eq.0)then
<                call na_tst_opt()
<             else
<                call con_min_opt()
<             endif
---
>             call na_tst_opt()
25910c25983
< c      read (21,'(A70)') comline1
---
> c      read (21,'(A300)') comline1
26102a26176,26177
> c lc: G16 implementation  [] 
> c check the correctness of the actual implementation
26108,26111c26183,26186
<             read (21,'(A70)') comline1
<             read (21,'(A70)') comline2
<             read (21,'(A70)') comline3
<             read (21,'(A70)') comline4
---
>             read (21,'(A300)') comline1
>             read (21,'(A300)') comline2
>             read (21,'(A300)') comline3
>             read (21,'(A300)') comline4
26370c26445
< 
---
>       call ModRPHt(0,RPHT_custom_flag)
26565c26640,26641
<       dimension tau(ntaumx),taumn(ntaumx),taumx(ntaumx),freq(nmdmx)
---
>       dimension tau(ntaumx),taumn(ntaumx),taumx(ntaumx),freq(nmdmx),
>      $tauopt(ntaumx)
26569d26644
< 
26589c26664
<       character*70 comline1,comline2
---
>       character*300 comline1,comline2
26593a26669,26679
> !  lc :  Gaussian command line for HLEVEL_TS level of theory
>       character*200 GCmLin1,GCmLin2
> !  lc :  iGOpMod little documentation
> !        the value of this variable set if 
> !        the active space must be read or not
> !        iGOpMod=0 --> no gaussian procedure is checked 
> !        active space must be specified
> !        iGOpMod=1 --> no active space for level1_ts 
> !        iGOpMod=2 --> no active space for hlevel_ts 
> !        iGOpMod=3 --> no active space for hlevel_ts and level1_ts 
> !        This variable is set to communicate with vrc_tst subroutine      
26600d26685
<       jcheck=0
26719d26803
<       if(word4.eq.'ALL')naddres=4
26741d26824
<       jcheck=1
26749d26831
< c         if(natom.gt.4)then
26752,26756c26834,26836
<          if(jcheck.eq.1)then
<             aabs2=aabs2v
<             babs2=babs2v
<             babs3=babs3v
<          endif
---
>          aabs2=aabs2v
>          babs2=babs2v
>          babs3=babs3v
26765,26767d26844
< c      write(*,*)' aabs1 ',aabs1
< c      stop
< 
26799d26875
< 
26801d26876
< 
26803a26879,26882
> c  lc :  possible problem here, no active space defined
> c        in pure gaussian/DFT protocol.
> c        add a goto to rewind(13) statement line
> c        if HL e level1 index_v point to G09 procedure
26806,26814d26884
<       word=''
<       do while (WORD.NE.'AS_VRC')
<          call LineRead (13)
<          if (WORD.EQ.'END') then
<             write(7,*) 'active space and orbitals for VRC'
<             write(7,*) 'must be described in theory.dat'
<             stop
<          endif
<       enddo
26816,26819c26886,26900
<       read (13,*) cjunk,nbonds_vrc
<       read (13,*) cjunk,nlps_vrc
<       read (13,*) cjunk,nstates_vrc
<       rewind(13)
---
> c  lc : DEBUG OLD 
> c      word=''
> c      do while (WORD.NE.'AS_VRC')
> c         call LineRead (13)
> c         if (WORD.EQ.'END') then
> c            write(7,*) 'active space and orbitals for VRC'
> c            write(7,*) 'must be described in theory.dat'
> c            stop
> c         endif
> c      enddo
> c
> c      read (13,*) cjunk,nbonds_vrc
> c      read (13,*) cjunk,nlps_vrc
> c      read (13,*) cjunk,nstates_vrc
> c      rewind(13)
26824,26826c26905,26907
<          call LineRead (13)
<          if (WORD.EQ.'END') then
<             write(7,*) 'level1 of theory '
---
>         call LineRead (13)
>          if (WORD.EQ.'END') then 
>             write(7,*) 'level1(ts) of theory '
26830a26912
> c lc: G16 implementation  [x] 
26833,26834c26915,26928
<          read (13,'(A70)') comline1
<          read (13,'(A70)') comline2
---
>          iGOpMod = 1
>          read (13,'(A300)') comline1
>          read (13,'(A300)') comline2
>          open(unit=977,file='GCntrFile.dat',status='unknown')
>          write(977,'(I0)') iGOpMod
>          close(977,status='keep')
>       else if(word2.eq.'G16')then
>          ilev0code=3
>          iGOpMod = 1
>          read (13,'(A300)') comline1
>          read (13,'(A300)') comline2
>          open(unit=977,file='GCntrFile.dat',status='unknown')
>          write(977,'(I0)') iGOpMod
>          close(977,status='keep')
26849a26944,26972
>       rewind(13)
> c  lc : DEBUG NEW 
>          word=''
>          if (ilev0code.eq.2) then 
>             do while (WORD.NE.'AS_VRC')
>                call LineRead (13)
>                if (WORD.EQ.'END') then
>                   write(7,*) 'active space and orbitals for VRC'
>                   write(7,*) 'must be described in theory.dat'
>                   stop
>                endif
>             enddo 
> 
>             read (13,*) cjunk,nbonds_vrc
>             read (13,*) cjunk,nlps_vrc
>             read (13,*) cjunk,nstates_vrc
>             rewind(13)
> c  lc :  if Molpro is not used, then, a full gaussian approach
> c        will be assumed. However the above read variables still 
> c        need an inizialization since they will be necessary for 
> c        vrc_tst procedure
>          else if (ilev0code.eq.1.or.ilev0code.eq.3) then
> c  lc :  set the global variable iGopMod to 1
>             nbonds_vrc = 1
>             nlps_vrc = 0
>             nstates_vrc = 1
>          end if
> 
> 
26852a26976,26981
> c  lc :  start potcorr explicit wavefun protocol 
> c        probably it is necessary to generate
> c        active space files even with gaussian procedure
> c        but I need to verify
> c     molpro (ilev0code = 2)
> 
26861c26990
<         call activespace(nbonds_vrc,nlps_vrc,nstates_vrc,neltot,ispin)
---
>          call activespace(nbonds_vrc,nlps_vrc,nstates_vrc,neltot,ispin)
26895c27024
<          if(natom2.eq.1.and.natom1.gt.2)then
---
>          if(natom2.eq.1)then
26899,26902d27027
<          else if(natom2.eq.1.and.natom1.eq.2)then
<             command1="sed -ie 's/inactive,/active,aabs1/' 
<      $ level0_molpro1.dat"
<             call commrun(command1)
27039c27164,27167
<       else if (ilev0code.eq.1)then
---
> 
> c lc :   start gaussian procedure
>       else if (ilev0code.eq.1.or.ilev0code.eq.3)then
>         write(7,*) 'entered in gaussian procedure'
27042a27171
> c lc  :  no freq computation?   
27046c27175,27176
<         read(99,'(A70)')comline1
---
> c lc :   debug reading ?         
>         read(99,'(A300)')comline1
27052c27182
<         call commrun(command1)
---
>         call commrun(command1)  
27054c27184,27185
<         read(99,'(A70)')comline2
---
> c lc :   debug reading ?         
>         read(99,'(A300)')comline2
27060a27192
> c  lc :  active space generation (?)
27093a27226,27228
> c  lc :  guess potential, 
> c        error in debug line, it opens the ts.dat 
> c        file, not the theory.dat
27102c27237,27238
<                write(7,*) 'must be described in theory.dat'
---
> c               write(7,*) 'must be described in theory.dat'
>                write(7,*) 'must be described in ts.dat'
27136,27148c27272,27282
< cc move babs3 
<       if(natom1.ge.2.and.natom2.gt.2)then
<          do iint = 1 , nint
<             if(intcoori(iint).eq.'BABS3')then
<                intcoor(1)='BABS3'
<                xint(1)=xinti(iint)
<                intcoor(iint)=intcoori(1)
<                xint(iint)=xinti(1)
<             endif
<          enddo
<       endif
< cc move babs2 
<       if(natom1.ge.2.and.natom2.gt.2)then
---
> cc move aabs1 to first position
>       do iint = 1 , nint
>          if(intcoori(iint).eq.'AABS1')then
>             intcoor(1)='AABS1'
>             xint(1)=xinti(iint)
>             intcoor(iint)=intcoori(1)
>             xint(iint)=xinti(1)
>          endif
>       enddo
> cc move babs1 to second position
>       if(natom1.ne.2)then
27150,27151c27284,27285
<             if(intcoori(iint).eq.'BABS2')then
<                intcoor(2)='BABS2'
---
>             if(intcoori(iint).eq.'BABS1')then
>                intcoor(2)='BABS1'
27157,27166c27291
<          else if (natom1.ge.2.and.natom2.eq.2)then
<             do iint = 1 , nint
<                if(intcoori(iint).eq.'BABS2')then
<                   intcoor(1)='BABS2'
<                   xint(1)=xinti(iint)
<                   intcoor(iint)=intcoori(1)
<                   xint(iint)=xinti(1)
<                endif
<             enddo
<        endif
---
>       endif
27168,27169c27293,27294
< cc move aabs2 
<       if(natom1.ge.2.and.natom2.gt.2)then
---
> cc move aabs2 to third position
>       if(natom1.ne.2)then
27178c27303
<       else if (natom1.ge.2.and.natom2.eq.2)then
---
>       else
27189,27190c27314,27315
< cc move babs1 
<       if(natom1.gt.2.and.natom2.gt.2)then
---
> cc move babs2 to fourth position
>       if(natom1.ne.2)then
27192,27193c27317,27318
<             if(intcoori(iint).eq.'BABS1')then
<                intcoor(4)='BABS1'
---
>             if(intcoori(iint).eq.'BABS2')then
>                intcoor(4)='BABS2'
27199c27324
<       else if (natom1.gt.2.and.natom2.eq.2)then
---
>       else
27201,27202c27326,27327
<             if(intcoori(iint).eq.'BABS1')then
<                intcoor(3)='BABS1'
---
>             if(intcoori(iint).eq.'BABS2')then
>                intcoor(3)='BABS2'
27208,27216d27332
<       else if (natom1.gt.2.and.natom2.eq.1)then
<          do iint = 1 , nint
<             if(intcoori(iint).eq.'BABS1')then
<                intcoor(1)='BABS1'
<                xint(1)=xinti(iint)
<                intcoor(iint)=intcoori(1)
<                xint(iint)=xinti(1)
<             endif
<          enddo
27218,27219c27334,27335
< cc move abs1
<       if(natom1.gt.2.and.natom2.gt.2)then
---
> cc move babs3 to fifth position
>       if(natom1.ne.2)then
27221,27222c27337,27338
<             if(intcoori(iint).eq.'AABS1')then
<                intcoor(5)='AABS1'
---
>             if(intcoori(iint).eq.'BABS3')then
>                intcoor(5)='BABS3'
27228,27272d27343
<       else if(natom1.gt.2.and.natom2.eq.2)then
<          do iint = 1 , nint
<             if(intcoori(iint).eq.'AABS1')then
<                intcoor(4)='AABS1'
<                xint(4)=xinti(iint)
<                intcoor(iint)=intcoori(4)
<                xint(iint)=xinti(4)
<             endif
<          enddo
<       else if(natom1.gt.2.and.natom2.eq.1)then
<          do iint = 1 , nint
<             if(intcoori(iint).eq.'AABS1')then
<                intcoor(2)='AABS1'
<                xint(2)=xinti(iint)
<                intcoor(iint)=intcoori(2)
<                xint(iint)=xinti(2)
<             endif
<          enddo
<       else if(natom1.eq.2.and.natom2.gt.2)then
<          do iint = 1 , nint
<             if(intcoori(iint).eq.'AABS1')then
<                intcoor(4)='AABS1'
<                xint(4)=xinti(iint)
<                intcoor(iint)=intcoori(4)
<                xint(iint)=xinti(4)
<             endif
<          enddo
<       else if(natom1.eq.2.and.natom2.eq.2)then
<          do iint = 1 , nint
<             if(intcoori(iint).eq.'AABS1')then
<                intcoor(3)='AABS1'
<                xint(3)=xinti(iint)
<                intcoor(iint)=intcoori(3)
<                xint(iint)=xinti(3)
<             endif
<          enddo
<       else if(natom1.eq.2.and.natom2.eq.1)then
<          do iint = 1 , nint
<             if(intcoori(iint).eq.'AABS1')then
<                intcoor(1)='AABS1'
<                xint(1)=xinti(iint)
<                intcoor(iint)=intcoori(1)
<                xint(iint)=xinti(1)
<             endif
<          enddo
27274d27344
< 
27322c27392
<             read(15,'(A100)')comline1
---
>             read(15,'(A300)')comline1
27327c27397
<             read(16,'(A100)')comline1
---
>             read(16,'(A300)')comline1
27339c27409
<       if(ilev0code.eq.1) then
---
>       if(ilev0code.eq.1.or.ilev0code.eq.3) then
27344,27345c27414,27415
<          else if (natom1.eq.2)then
<             ircons=nint-4
---
>          else if (natom1.eq.2.and.natom2.eq.2)then
>             ircons=nint-3
27351,27356c27421,27427
< cc if using gaussian for optimization of ref distance then set spin from 1 to 3
<          ispinsave=0
<          if(ipottype.eq.3.and.ispin.eq.1)then
<             ispinsave=ispin
<             ispin=3
<          endif
---
> c  lc :  DEBUG
> c        entering in g09 
>          if (idebug.ge.2) write (7,*) 'entering g09fopt'
>          if (idebug.ge.2) write (7,*) 'comline1 is', comline1
>          if (idebug.ge.2) write (7,*) 'comline2 is', comline2
> 
> c
27359c27430,27443
<          ires=1
---
> c  lc :  Geometry potential correction here
> c        g09fopt should produce a geom.com file
> c        with a constrained optimization to the distance
> c        and the transitional coordinates only.
> c        modredundant keyword + "A" gaussian flag
> c        for internal coordinates that specify the transitionale
> c        degrees of freedom 
>          if (ipottype.eq.6) then 
>                open(unit=91,file='skipgeominf.dat',status='new',
>      &          iostat=i_status,action='write')
>                if (i_status .ne. 0) stop 
>                write(91,*) 6
>                close(91,status='keep')
>             end if
27365a27450
> 
27368d27452
<          if(ipottype.eq.3.and.ispinsave.eq.1)ispin=ispinsave
27419,27433d27502
<       check=(-vtotr+vtotref)*627.5
< 
<       if(check.gt.1.or.vtotr.gt.0)then
<          write(7,*)'failed in geom pot correction'
<          write(7,*)'in subroutine pot_corr'
<          write(7,*)'with vtotref-vtot ',check
<          write(7,*)'terminating code with error'
<          open(unit=99,file='failed',status='unknown')
<          write(99,*)'failed in geom pot correction'
<          write(99,*)'in subroutine pot_corr'
<          write(99,*)'with vtorref-vtot ',check
<          close(99)
<          stop
<       endif
< 
27526a27596
> c  lc : DEBUG 
27530,27537c27600,27608
<       do while (WORD.NE.'AS_VRC')
<          call LineRead (13)
<          if (WORD.EQ.'END') then
<             write(7,*) 'active space and orbitals for VRC'
<             write(7,*) 'must be described in theory.dat'
<             stop
<          endif
<       enddo
---
>       if (ilev0code.eq.2) then 
>          do while (WORD.NE.'AS_VRC')
>             call LineRead (13)
>             if (WORD.EQ.'END') then
>                write(7,*) 'active space and orbitals for VRC'
>                write(7,*) 'must be described in theory.dat'
>                stop
>             endif
>          enddo
27539,27542c27610,27618
<       read (13,*) cjunk,nbonds
<       read (13,*) cjunk,nlps
<       read (13,*) cjunk,nstates
<       close(13)
---
>          read (13,*) cjunk,nbonds
>          read (13,*) cjunk,nlps
>          read (13,*) cjunk,nstates
>       else if (ilev0code.eq.1.or.ilev0code.eq.3) then
> c  lc :  probably iGOpMod assignment is redundant here
>          nbonds=0
>          nlps=0
>          nstates=0
>       end if
27543a27620
>          close(13)
27546c27623,27643
< 
---
> c lc  debug:   new search of HLEVEL keyword. It should be noted here
> c              that there are not useful informations by this reading
> c              it serves as direction for processing of hlevel files
> c              for the referement energy reading START
>          do while (WORD.NE.'HLEVEL')
>             call LineRead (13)
>             if (WORD.EQ.'END') then
>                write(7,*) 'hlevel of theory '
>                write(7,*) 'must be described in theory.dat'
>                stop
>             endif
>          enddo
>          if(word2.eq.'G09')then
>             ilev1code=1
>          else if (word2.eq.'G16') then
>             ilev1code=3
>          else if (word2.eq.'MOLPRO') then
>             ilev1code=2
>          end if 
>       rewind(13)
> c lc debug END
27550c27647
<             write(7,*) 'level1 of theory '
---
>             write(7,*) 'hlevel_ts of theory '
27555d27651
<       close(13)
27556a27653,27654
> c lc: G16 implementation  [x] 
> c special check on this correction
27557a27656,27657
>          read(13,'(A300)') GCmLin1
>          read(13,'(A300)') GCmLin2
27559a27660,27679
> !  lc :  iGOpMode setting
> !        if iGOpMode is 1 then the level1as must 
> !        also be skipped. So iGOpMod is setted to 3 
>          if (iGOpMod .eq. 1) then 
>             iGOpMod=3 
>          else if (iGOpMod .eq. 0) then 
>             iGOpMod = 2 
>          end if
>          close(13)
>       else if(word2.eq.'G16')then
>          read(13,'(A300)') GCmLin1
>          read(13,'(A300)') GCmLin2
>          ilev0code=3
>          ilevhlcode=3
>          if (iGOpMod .eq. 1) then 
>             iGOpMod=3 
>          else if (iGOpMod .eq. 0) then 
>             iGOpMod = 2 
>          end if
>          close(13)
27561a27682
> c         if (iGOpMod .eq. 1) iGopMod=0 
27567a27689,27692
> c  lc : write iOpMod out 
>       open(unit=977,file='GCntrFile.dat',status='unknown')
>          write(977,'(I0)') iGOpMod
>          close(977,status='keep')
27598c27723
<          read (15,'(A70)') comline2
---
>          read (15,'(A300)') comline2
27620c27745
<       read (12,'(A70)') comline1
---
>       read (12,'(A300)') comline1
27650c27775
<                read(15,'(A70)')comline1
---
>                read(15,'(A300)')comline1
27662c27787
<                read(15,'(A70)')comline1
---
>                read(15,'(A300)')comline1
27739c27864
<       if(ilev0code.eq.1) then
---
>       if(ilev0code.eq.1.or.ilev0code.eq.3) then
27740a27866,27871
> c  lc :  DEBUG LINE
>          if (idebug.ge.2) write (7,*) 'comline1 for hlevel ts is '
>      $,GCmLin1
>          if (idebug.ge.2) write (7,*) 'comline2 for hlevel ts is '
>      $,GCmLin2
> 
27744c27875
<      $        comline1,comline2,icharge,ispin,ircons,
---
>      $        GCmLin1,GCmLin2,icharge,ispin,ircons,
27747a27879
>          if (idebug.ge.2) write (7,*) 'vtotr hlts is',vtotr
27759,27761c27891,27905
< 
<       if(ilev0code.eq.2.and.ilevhlcode.eq.0) then
<          command1='egrep CBSEN  hl_logs/ts_molpro.out > en.dat'
---
>       open(unit=788,file='Temp_debug',status='unknown')
>       write(788,*) 'ilev1code is ', ilev1code 
>       write(788,*) 'ilev0code is ', ilev0code 
>       write(788,*) 'ilevhlcode is ', ilevhlcode 
>       close(788)
> c lc: todo , capire come modificare qui per g16,to test
> c lc: to test for a procedure in which molpro is used only for
> c     HLEVEL computation. In this case ilev1code is set to 2 
> c     while ilev0code is set to 1 or 3 if g09 or g16 is used
> c     for optimization and ilevhlcode can be 1,2 or 3 based on
> c     code used for HLEVEL_TS  
>       if(ilev1code.eq.2) then
> c previous string 
> c if(ilev1code.eq.2.and.ilevhlcode.eq.0) then         
>          command1='egrep -w CBSEN hl_logs/ts_molpro.out > en.dat'
27766,27772c27910
<       else if (ilev0code.eq.1.or.ilev0code.eq.3) then
<          command1='egrep SCF  hl_logs/ts_g09.out > en.dat'
<          call commrun(command1)
<          open (unit=99,file='./en.dat',status='old')
<          read(99,*)cjunk,cjunk,cjunk,cjunk,vtotref
<          close(99)
<       else if (ilev0code.eq.2.and.ilevhlcode.eq.1) then
---
>       else if (ilev1code.eq.1.or.ilev1code.eq.3) then
27777a27916,27922
> c      else if (ilev0code.eq.2.and.
> c     $        (ilevhlcode.eq.1.or.ilevhlcode.eq.3))  then
> c         command1='egrep SCF  hl_logs/ts_g09.out > en.dat'
> c         call commrun(command1)
> c         open (unit=99,file='./en.dat',status='old')
> c         read(99,*)cjunk,cjunk,cjunk,cjunk,vtotref
> c         close(99)
27790c27935
<       if(ipottype.eq.3.or.ipottype.eq.5)then
---
>       if(ipottype.eq.3.or.ipottype.eq.5.or.ipottype.eq.6)then
27805d27949
<          close(13)
27806a27951,27952
> c lc: G16 implementation  [x]
> c special check on this 
27809a27956,27972
>             read(13,'(A300)') GCmLin1
>             read(13,'(A300)') GCmLin2
>             if (iGOpMod .eq. 1) then 
>                iGOpMod=3 
>             else if (iGOpMod .eq. 0) then 
>                iGOpMod = 2 
>             end if
>          else if(word2.eq.'G16')then
>             read(13,'(A300)') GCmLin1
>             read(13,'(A300)') GCmLin2
>             ilev0code=3
>             ilevhlcode=3
>             if (iGOpMod .eq. 1) then 
>                iGOpMod=3 
>             else if (iGOpMod .eq. 0) then 
>                iGOpMod = 2 
>             end if
27814a27978,27979
>          else if (word3.eq.'G16') then 
>             ilev0code=3
27817a27983,27987
>          close(13)
>          open(unit=977,file='GCntrFile.dat',status='unknown')
>          write(977,'(I0)') iGOpMod
>          close(977,status='keep')
> 
27836c28006
<             read (15,'(A70)') comline2
---
>             read (15,'(A300)') comline2
27858c28028
<         read (12,'(A70)') comline1
---
>         read (12,'(A300)') comline1
27950,27951c28120,28128
< 
<          if(ilev0code.eq.1) then
---
> c  lc Ipottype = 6: in this case an high level computation is required on infinite
> c                    separation without the necessity to redo the constrained optimization
> c                    In this case ipottype, 6 , is written in a file called skipgeoming.dat
> c                    This file will be read by g09fopt and delted by it and serves as control
> c                    Section. In case this is checked true g09fopt will chekc in this file
> c                    If 6 is written on it. Then if in geoms potcorrgeom.log is found.  
> c                    In that case that file wil be copied in a geom.log file and processed
> c                    without calling the g09/16 executable. 
>          if(ilev0code.eq.1.or.ilev0code.eq.3) then
27955c28132
<      $           comline1,comline2,icharge,ispin,ircons,
---
>      $           GCmLin1,GCmLin2,icharge,ispin,ircons,
28379c28556
<       character*70 comline1,comline2
---
>       character*300 comline1,comline2
28584c28761
<          do j=4,natomt
---
>          do j=4,natom
28586,28609c28763,28770
<                if(idummy(j).eq.0)then
<                   if(intcoor(k).eq.bname(j))then
<                      bd=xint(k)
<                   endif
<                   if(intcoor(k).eq.anname(j))then
<                      ang=xint(k)
<                   endif
<                   if(intcoor(k).eq.dname(j))then
<                      dihed=xint(k)
<                   endif
<                else if(idummy(j).eq.1)then
< c                  write(*,*)'found dummy atom in sub zmat to xyz'
< c                  write(*,*)'idummy is ',j
< c                  write(*,*)'bd is ',bname(j)
< c                  write(*,*)'ang is ',anname(j)
< c                  write(*,*)'dihed is ',dname(j)
<                   read(bname(j),111)bd
<                   read(anname(j),111)ang
<                   read(dname(j),111)dihed
< c                  write(*,*)' bd now is ',bd
< c                  write(*,*)' ang now is ',ang
< c                  write(*,*)' dihed now is ',dihed
<  111              format(f7.4)
< c                  stop
---
>                if(intcoor(k).eq.bname(j))then
>                   bd=xint(k)
>                endif
>                if(intcoor(k).eq.anname(j))then
>                   ang=xint(k)
>                endif
>                if(intcoor(k).eq.dname(j))then
>                   dihed=xint(k)
28642,28645c28803,28804
<       do j=1,natomt
<          if(idummy(j).ne.1)then
<             write(15,100)atname(j),coox(j),cooy(j),cooz(j)
<          endif
---
>       do j=1,natom
>          write(15,100)atname(j),coox(j),cooy(j),cooz(j)
28647d28805
< c      stop
28682,28687d28839
<       aabs1v=0.
<       babs1v=0.
<       aabs2v=0.
<       babs2v=0.
<       babs3v=0.
< 
28690,28727c28842,28847
<       if(natom.gt.3)then
<          if(ibond.lt.3)then
<             write(7,*)'automatic det of transitional'
<             write(7,*)'is not possible with ibond smaller than 3'
<             write(7,*)'disable jk bond line and restart'
<             stop
<          endif
<          if(ibond.eq.3.and.natom.eq.4)then
<             call LineRead3 (15)
<             do j=1,natomt
<                call LineRead3 (15)
<                if(j.eq.ibond)then
<                   aabs1_name=word5
<                endif
<             enddo
< 
<             rewind(15)
<             call LineRead3 (15)
<             do j=1,natomt
<                call LineRead3 (15)
<                if(j.eq.jbond)then
<                   aabs2_name=word5
<                   babs2_name=word7
<                endif
<             enddo
<             nvar=3*natom-6
<             do j=1,nvar
<                read(15,*)vname,vvalue
< c         write(*,*)aabs2_name,vname,vvalue
<                if(vname.eq.aabs1_name)aabs1v=vvalue
< c               if(vname.eq.babs1_name)babs1v=vvalue
<                if(vname.eq.aabs2_name)aabs2v=vvalue
< c               if(vname.eq.aabs1_name)write(*,*)'read var1'
< c               if(vname.eq.aabs2_name)write(*,*)'read var2'
<                if(vname.eq.babs2_name)babs2v=vvalue
< c               if(vname.eq.babs3_name)babs3v=vvalue
<             enddo
< c         write(*,*)aabs2v
---
>       if(ibond.lt.4)then
>          write(7,*)'automatic det of transitional'
>          write(7,*)'is not possible with ibond smaller than 4'
>          write(7,*)'disable jk bond line and restart'
>          stop
>       endif
28729,28730c28849
<          else if(ibond.gt.3)then
<             call LineRead3 (15)
---
>       call LineRead3 (15)
28735,28781c28854
<             do j=1,natomt
<                call LineRead3 (15)
<                if(j.eq.ibond)then
<                   aabs1_name=word5
<                   babs1_name=word7
<                endif
<             enddo
< 
<             rewind(15)
<             call LineRead3 (15)
< 
<             do j=1,natomt
<                call LineRead3 (15)
<                if(j.eq.jbond)then
<                   aabs2_name=word5
<                   babs2_name=word7
<                endif
<                if(j.eq.kbond)then
<                   babs3_name=word7
<                endif
<             enddo
<             nvar=3*natom-6
<             do j=1,nvar
<                read(15,*)vname,vvalue
< c         write(*,*)vname,vvalue
<                if(vname.eq.aabs1_name)aabs1v=vvalue
<                if(vname.eq.babs1_name)babs1v=vvalue
<                if(vname.eq.aabs2_name)aabs2v=vvalue
<                if(vname.eq.babs2_name)babs2v=vvalue
<                if(vname.eq.babs3_name)babs3v=vvalue
<             enddo
< c      write(*,*)aabs1_name,aabs1v
< c      write(*,*)babs1_name,babs1v
< c      write(*,*)aabs2_name,aabs2v
< c      write(*,*)babs2_name,babs2v
< c      write(*,*)babs3_name,babs3v
< c      stop
< 
< c 1000 continue 
<          else
<             write(7,*)'automatic det of transitional'
<             write(7,*)'is not possible with ibond smaller than 4'
<             write(7,*)'and natom gt 4'
<             write(7,*)'disable jk bond line and restart'
<             stop
<          endif
<       else if (natom.eq.3) then
---
>       do j=1,natomt
28782a28856,28860
>          if(j.eq.ibond)then
>             aabs1_name=word5
>             babs1_name=word7
>          endif
>       enddo
28784,28793c28862,28863
< c      write(*,*)'natom is',natom
< c      write(*,*)'natomt is',natomt
< 
<          do j=1,natomt
<             call LineRead3 (15)
<             if(j.eq.ibond)then
<                aabs1_name=word5
< c               babs1_name=word7
<             endif
<          enddo
---
>       rewind(15)
>       call LineRead3 (15)
28795c28865
<          rewind(15)
---
>       do j=1,natomt
28797,28810c28867,28877
< 
<          do j=1,natomt
<             call LineRead3 (15)
< c            if(j.eq.jbond)then
< c               aabs2_name=word5
< c               babs2_name=word7
< c            endif
< c            if(j.eq.kbond)then
< c               babs3_name=word7
< c            endif
<          enddo
<          nvar=3*natom-6
<          do j=1,nvar
<             read(15,*)vname,vvalue
---
>          if(j.eq.jbond)then
>             aabs2_name=word5
>             babs2_name=word7
>          endif
>          if(j.eq.kbond)then
>             babs3_name=word7
>          endif
>       enddo
>       nvar=3*natom-6
>       do j=1,nvar
>          read(15,*)vname,vvalue
28812,28817c28879,28884
<             if(vname.eq.aabs1_name)aabs1v=vvalue
< c            if(vname.eq.babs1_name)babs1v=vvalue
< c            if(vname.eq.aabs2_name)aabs2v=vvalue
< c            if(vname.eq.babs2_name)babs2v=vvalue
< c            if(vname.eq.babs3_name)babs3v=vvalue
<          enddo
---
>          if(vname.eq.aabs1_name)aabs1v=vvalue
>          if(vname.eq.babs1_name)babs1v=vvalue
>          if(vname.eq.aabs2_name)aabs2v=vvalue
>          if(vname.eq.babs2_name)babs2v=vvalue
>          if(vname.eq.babs3_name)babs3v=vvalue
>       enddo
28824,28827d28890
< 
< 
<       endif
< 
28829a28893,28894
>  1000 continue 
> 
28853c28918
<       character*70 comline1,comline2
---
>       character*300 comline1,comline2
28877c28942
< calb  code was adapted to double precision as suggested in comments
---
> c alb  code was adapted to double precision as suggested in comments
28889c28954
< calb  from Numerical Recipes in FORTRAN77 page 244
---
> c alb  from Numerical Recipes in FORTRAN77 page 244
28924c28989
< calb  from Numerical Recipes in FORTRAN77 page 241
---
> c alb  from Numerical Recipes in FORTRAN77 page 241
29066c29131
< calb  from Numerical Recipes in FORTRAN77 page 236
---
> c alb  from Numerical Recipes in FORTRAN77 page 236
29240c29305
< calb  from Numerical Recipes in FORTRAN77 page 239
---
> c alb  from Numerical Recipes in FORTRAN77 page 239
29263c29328,29434
< calb  from Numerical Recipes in FORTRAN77 page 187
---
> 
> 
>       subroutine ModRPHt(specpointer,RPHT_custom_flag)
> c     THIS SUBROUTINE TAKES IN INPUT THE SPEC POINTER THAT IS AN INTEGER
> c     THAT INDICATES THE SPECIE'S TYPE. 
> c     0 stands for the ts
> c     1 stands for the reac1 
> c     2 stands for the reac2
> c     3 stands for the prod1
> c     4 stands for the prod2
> c     5 stands for the wellr
> c     6 stands for the wellp 
> c     THEN CHECKS IS THE CUSTOM RPHT FLAG IS ACTIVE FOR THAT SPECIES BY
> c     CHECKING THE ARRAY RPTH_CUSTOM_FLAG
> c     IF IT IS ACTIVE THEN SET A RESEARCH PATTERN IN THE 
> c     ESTOKTP/DATA/ESTOKTP.DAT FILE TO TAKE THE CUSTOM PARAMETERS 
> c     PIVOTA,PIVOTB,CSTMATOMSINTOPA,CSTMTOPAATOMS
> c     THEN IT CALLS THE PYTHON SCRIPT TO MODIFY THE RPHT INPUT FILE AS
> c     DESIRED
> c     IN ORDER TO USE CUSTOM RHPT INPUT DATA FOR ROTOR TREATMENT THE USER
> c     SHOULD SPECIFY IN DATA/ESTOKTP.DAT
> c     RPHTCUSTOM SPEC_LABEL PIVOTA PIVOTB ATOMSPA TOPAATOMS 
> 
> 
> c     DECLARATION SECTION
>          integer specpointer
>          integer :: debugkey
>          integer*8 RPHT_custom_flag(0:6)
>          character*256 string,keytomatch,localcommand
>          integer CstmPivotA,CstmPivotB,CstmAtomsInTopA,CstmTopAAtoms
>          character*30 JunkChar
> 
> 
>             debugkey = 0
>          if (debugkey .eq. 2) then 
>             open(unit=777,file='tempdebuggingcustomrpht.log')
>             write(777,'(I0,/)') RPHT_custom_flag
>          end if
>          if (specpointer .eq. 61) specpinter = 6 
>          if (specpointer .eq. 51) specpinter = 5
>          if (RPHT_custom_flag(specpointer).eq.1) then
>             select case (specpointer)
>                case(0)
>                keytomatch='ts'
>                case(1)
>                keytomatch='reac1'
>                case(2)
>                keytomatch='reac2'
>                case(3)
>                keytomatch='prod1'
>                case(4)
>                keytomatch='prod2'
>                case(5)
>                keytomatch='wellr'
>                case(6)
>                keytomatch='wellp'
>             end select
>             open(unit=888,file='data/estoktp.dat',action='read',
>      $       status='old')
>          if (debugkey .eq. 2) then 
>             open(unit=777,file='tempdebuggingcustomrpht.log')
>             write(777,*) keytomatch
>          end if
>          do 
>             read(888,'(A)') string
>             string = trim(adjustl(string))
>             if (debugkey .eq. 2) then 
>                open(unit=777,file='tempdebuggingcustomrpht.log')
>                write(777,*) string
>             end if
> 
>             if (
>      &         (index(string,'RPHTCUSTOM').gt.0)
>      &         .and. 
>      &         (index(string,trim(keytomatch)).gt.0)) 
>      &         then
>             read(string,*) 
>      &         JunkChar,JunkChar,CstmPivotA,CstmPivotB,
>      &         CstmAtomsInTopA,CstmTopAAtoms
>          if (debugkey .eq. 2) then 
>             open(unit=777,file='tempdebuggingcustomrpht.log')
>             write(777,*) 'Condition checked'
>          end if
>             close(888)
>             exit
>             end if
> 
>          end do 
>          else
>             return
>          end if
>          write(localcommand,1234) CstmPivotA,CstmPivotB,CstmAtomsInTopA,
>      &    CstmTopAAtoms
> 
> 
> 
>  1234 format(  'HandlerLouncher.sh ',
>      $         '-PA',1x,I0,1x,
>      $         '-PB',1x,I0,1x,
>      $         '-atinA',1x,I0,1x,
>      $         '-TopAAt',1x,I0)
> 
>          call commrun(localcommand)
> c          stop 'debug stop by modrpht'
>       end subroutine ModRPHt
> 
> c alb  from Numerical Recipes in FORTRAN77 page 187
29285a29457
>       
29288,31065c29460
< cadl Subroutine to call Double Ended GSM for isomerization reactions.
< c    Modified from grid_opt_iso
< c    Requires both REAC1 and PROD1 structures
< 
<       subroutine gsm_opt_iso
< 
<       implicit double precision (a-h,o-z)
<       implicit integer (i-n)
< 
<       include 'data_estoktp.fi'
<       include 'param_estoktp.fi'
< 
<       dimension tau(ntaumx),taumn(ntaumx),taumx(ntaumx),freq(nmdmx)
<       dimension coord(natommx,ndim),xint(3*natommx),xinti(3*natommx),
<      $ abcrot(ndim)
<       dimension xints(3*natommx)
<       dimension tauopt(ntaumx)
<       dimension drea(noptmx)
< 
<       character*70 comline1,comline2,copystuff
<       character*60 atomlabel(natommx)
<       character*60 atomlabel1(natommx)
<       character*30 intcoor(3*natommx)
<       character*30 intcoors(3*natommx)
<       character*20 bislab(ntaumx)
<       character*30 gmem
<       character*70 command1
<       character*40 filename
<       character*4  cjunk
<       character*100 commandcopy
<       character*30 dih_rot
< 
<       LOGICAL leof,lsec,ltit,ex
< 
<       CHARACTER*1000 line,string
<       CHARACTER*160 sename,word,word2,word3,title,title1,
<      $ word4,word5,word6,word7
< 
< cadl Things necessary to play with zmat_routines
<       dimension ibconn(natommx),iaconn(natommx),idconn(natommx)
<       dimension idummy(natommx)
< c      character*60 atomlabel(natommx)
< c      character*30 intcoor(3*natommx)
< c      character*20 bislab(ntaumx)
<       character*20 bname(natommx),anname(natommx),dname(natommx)
<      $ ,atname(natommx),bconnt(natommx),aconnt(natommx),dconnt(natommx)
<       character*1 xread
<       character*5 ccheck
< c      LOGICAL leof,lsec,ltit
< c      CHARACTER*1000 line,string
< c      CHARACTER*160 sename,word,word2,word3
< c     $ ,title,title1,word4,word5,word6,word7
<       character*6 ct1,ct2,ct3,ct4,ct5,ct6,ct7
< c      include 'filcomm.f'
< 
<       include 'filcomm.f'
< 
< c parameter initialization
<       ires=1
<       ireac_geom=0
<       iprod_geom=0
<       iaspace=0
< 
< c input data
<       open (unit=25,file='./data/ts.dat',status='old')
<       open (unit=26,file='./output/gsm_opt.out',status='unknown')
<       open (unit=21,file='./data/theory.dat',status='unknown')
< 
< cadl Reads info from ts.dat
< c read charge and spin
<       do while (WORD.NE.'CHARGE')
<          call LineRead (25)
<          if (WORD.EQ.'END') then
<             write (26,*) 'charge and spin must be defined'
<             stop
<          endif
<       enddo
<       read (25,*) icharge,ispin
<       rewind (25)
<       write (26,*) 'Read TS charge and spin: ',icharge,ispin
< c read isite jsite ksite
<       do while (WORD.NE.'ISITE')
<          call LineRead (25)
<          if (WORD.EQ.'END') then
<             write (26,*) 'reaction site must be defined'
<             stop
<          endif
<       enddo
<       read (25,*) isite,jsite,ksite
<       rewind (25)
<       write (26,*) 'Read i,j,k sites: ',isite,jsite,ksite
< c reads rmin, just need ireact!
<       do while (WORD.NE.'RMIN1')
<          call LineRead (25)
<          if (WORD.EQ.'END') then
<             write (26,*) 'grid coords must be defined'
<             stop
<          endif
<       enddo
<       read (25,*) cjunk,cjunk,cjunk,cjunk,ireact
<       rewind (25)
<       write (26,*) 'Read ireact: ',ireact
< c checks if user asks to use particular reac_geom ADDED KEYOWORD!
<       do while (WORD.NE.'REAC_GEOM')
<          call LineRead (25)
<          if (WORD.EQ.'END') then
<             rewind(25)
<             goto 999
<          endif
<       enddo
<       read (25,*) ireac_geom
<       write (26,*) 'It is requested to use reac_geom n. ',ireac_geom
<  999  continue
<       rewind(25)      
< c checks if user asks to use particular prod_geom ADDED KEYOWORD!
<       do while (WORD.NE.'PROD_GEOM')
<          call LineRead (25)
<          if (WORD.EQ.'END') then
<             rewind(25)
<             goto 998
<          endif
<       enddo
<       read (25,*) iprod_geom
<       write (26,*) 'It is requested to use prod_geom n. ',iprod_geom
<  998  continue
<       rewind(25)
<       close (25)
< 
< cadl Get number of atoms from reac1.dat
<       open (unit=15,file='./data/reac1.dat',status='old')
< c get atom number, doesn't care for dummy so natomt1 not used
< c for now. Will have to account for it going back to zmat maybe?      
<       do while (WORD.NE.'NATOM')
<          call LineRead (15)
<          if (WORD.EQ.'END') then
<             write (26,*) 'natom must be defined'
<             stop
<          endif
<       enddo
<       read (15,*) natom1,natomt1
<       rewind (15)
<       close (15)
<       natom=natom1
<       natomt=natomt1
< 
< cadl Choose reactant structure for calculation
< c first determine how many structures were determined with the rotational scan
<       command1='ls output/reac1_opt_* > temp.log '
<       call commrun(command1)
<       command1='grep -c ^ temp.log > num.log'
<       call commrun(command1)
<       open (unit=99,file='num.log',status='unknown')
<       read (99,*) numstruct_reac
<       close (unit=99,status='keep')
<       write (26,*) 'Read numstruct reac: ',numstruct_reac
< c now open the xyz files and search the one with the minimum distance
< c between the reacting atoms
<       write (26,*) 'Distance between ireact and isite'
<       do j=1,numstruct_reac
<          open (unit=99,status='unknown')
<          write(99,1201)j
<          rewind (99)
<          read (99,'(A40)') filename
<          close (99)
<          write(26,*) 'filename is ',filename
<          open(unit=23,file=filename,status='unknown')
<          read (23,*)
<          read (23,*)
<          do k=1,natom
<             read (23,*)cjunk,coox,cooy,cooz
<             if(k.EQ.ireact)then
<                coox1=coox
<                cooy1=cooy
<                cooz1=cooz
<             endif
<             if(k.EQ.isite)then
<                coox2=coox
<                cooy2=cooy
<                cooz2=cooz
<             endif
<          enddo
<          close(23)
<          drea(j)=sqrt((coox1-coox2)**2+(cooy1-cooy2)**2
<      $           +(cooz1-cooz2)**2)
<          write(26,*)'irea-isite dist for str ',j,' is ',drea(j)
<       enddo
< c now determine the reac structure with the minimum distance
<       iopt_reac=1
<       do j=1,numstruct_reac
<          if(drea(j).LT.drea(iopt_reac))then
<             iopt_reac=j
< c         write(*,*)'updating str ',j,' that has ',drea(j)
<          endif
<       enddo
<       write(26,*) 'the structure with the min dist is',iopt_reac
<       if (ireac_geom.NE.0)then 
<          iopt_reac=ireac_geom
<          write(26,*) 'forced from ts.dat the use of geom ',iopt_reac
<       endif      
< 
< ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
< c REPEAT FOR PRODUCT c
< c either same structures are required for reac and prod or a newisite and ireac...
< ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
< cadl Choose product structure for calculation
< c first determine how many structures were determined with the rotational scan
<       command1='ls output/prod1_opt_* > temp.log '
<       call commrun(command1)
<       command1='grep -c ^ temp.log > num.log'
<       call commrun(command1)
<       open (unit=99,file='num.log',status='unknown')
<       read (99,*) numstruct_prod
<       close (unit=99,status='keep')
<       write (26,*) 'Read numstruct prod: ',numstruct_prod
< c now open the xyz files and search the one with the minimum distance
< c between the reacting atoms
<       do j=1,numstruct_prod
<          open (unit=99,status='unknown')
<          write(99,1202)j
<          rewind (99)
<          read (99,'(A40)') filename
<          close (99)
<          write(26,*) 'filename is ',filename
<          open(unit=23,file=filename,status='unknown')
<          read (23,*)
<          read (23,*)
<          do k=1,natom
<             read (23,*)cjunk,coox,cooy,cooz
<             if(k.EQ.ireact)then
<                coox1=coox
<                cooy1=cooy
<                cooz1=cooz
<             endif
<             if(k.EQ.isite)then
<                coox2=coox
<                cooy2=cooy
<                cooz2=cooz
<             endif
<          enddo
<          close(23)
<          drea(j)=sqrt((coox1-coox2)**2+(cooy1-cooy2)**2
<      $           +(cooz1-cooz2)**2)
<          write(26,*)'irea-isite dist for str ',j,' is ',drea(j)
<       enddo
< c now determine the structure with the minimum distance
<       iopt_prod=1
<       do j=1,numstruct_prod
<          if(drea(j).LT.drea(iopt_prod))then
<             iopt_prod=j
< c         write(*,*)'updating str ',j,' that has ',drea(j)
<          endif
<       enddo
<       write(26,*) 'the structure with the min dist is',iopt_prod
<       if (iprod_geom.NE.0)then 
<          iopt_prod=iprod_geom
<          write(26,*) 'forced from ts.dat the use of prod geom ',iopt_prod
<       endif
< 
< cadl Funzione di restart da valutare e capire se si può fare TO DO
< c Level of theory
<       write (26,*) 'LOT'
<       do while (WORD.NE.'LEVEL0')
<          call LineRead (21)
<          if (WORD.EQ.'END') then
<             write (26,*) 'gaussian level0 of theory must be defined'
<             write (26,*) 'in file theory.dat'
<             stop
<          endif
<       enddo
<       if (word2.EQ.'G09') then
<          ilev0code=1
<       else
<          write (26,*) 'level0 of theory must be'
<          write (26,*) 'only g09 in theory.dat'
<          stop
<       endif
<       ! if(word3.eq.'RESTART') then
<       !    open (unit=99,status='unknown')
<       !    write (99,*) word4
<       !    rewind (99)
<       !    read (99,*) ires
<       !    close (unit=99,status='keep')
<       ! endif
<       if (ilev0code.eq.1) then
<          read (21,'(A70)') comline1
<       endif
<       close (21)
< cadl Quite sure there is a better way to do this but assuming that
< c    the beginning of the gaussian line in theory.dat is 
< c    [blank]theory/basisset if I start from 3rd position I should
< c    get it right. Probably would be easier to split into columns
< c    and get first column. TO IMPROVE!
<       k=3
<       do while (comline1(k:k).NE.' ')
<          k=k+1
<       enddo
<       write (26,*) 'Level of theory: '//comline1(:k)
< 
< cadl Write gstart file (g09 lot)
<       open (unit=59,file='./gstart',status='unknown')
<       write (59,*) '# '//comline1(:k)//' nosymm '//'Force '//'test'
<       write (59,*)
<       write (59,*) 'Title Card Required'
<       write (59,*)
<       write (59,*) icharge,ispin
<       close (59)
<       write (26,*) 'Writing input files:'
<       write (26,*) 'Written gstart file'
< 
< cadl Here ISOMERS is not needed but still I get information on the 
< c    connectivity and 
< c get number of internal coordinates
<       ncoord = 3*natom1-6
< c get connectivity of ireact in reac1
<       write (26,*) 'natom1, ncoord',natom1,ncoord
<       open (unit=15,file='./data/reac1.dat',status='old')
< c define ntau1
<       do while (WORD.NE.'NTAU')
<          call LineRead (15)
<          if (WORD.EQ.'END') then
<             write (6,*) 'sampling coordinates of reac1 must be defined'
<             stop
<          endif
<       enddo
<       read (15,*) ntau1
<       read (15,*)
<       if (ntau1.NE.0) then
<          do iint=1,ntau1
<             read (15,*) intcoor(ncoord-ntau1+iint),
<      $                  xint(ncoord-ntau1+iint),cjunk
< c            write(26,*) 'What reading?', intcoor(ncoord-ntau1+iint),
< c     $                  xint(ncoord-ntau1+iint)
<          enddo
<       endif
<       rewind (15)
< c  reading z-mat
<       do while (WORD.NE.'CHARGE')
<          call LineRead (15)  
<       enddo
<       call LineRead (15)
<       if (idebug.GE.2) write (26,*) 'reading z-mat input'
<       do iatom = 1 , natomt1
<          read (15,'(A60)') atomlabel(iatom)
< c         write (26,*) atomlabel(iatom)
<       enddo
< c read coordinate names
<       call LineRead (15)
<       do iint = 1 , ncoord-ntau1
<          read (15,*) intcoor(iint),xint(iint)
<       enddo
< c      do iint = 1 , ncoord
< c         write (26,*) 'intcoor, xint ',intcoor(iint),xint(iint)
< c      enddo
<       close (15)
< 
<       call read_zmat(atomlabel,natom1,natomt1,intcoor,bislab,ibconn,
<      $ iaconn,idconn,bname,anname,dname,atname,idummy,isited,jsited,
<      $ ksited,bconnt,aconnt,dconnt)
<       write (26,*)
<       write (26,*) 'Reading zmatrix connectivity:'
<       do j=1,natomt1
<          write (26,*)'at ',j,' conn is: ',ibconn(j),iaconn(j),idconn(j)
<       enddo
<       do j=1,natomt1
<          write (26,*)'at ',j,'bond ang dihed are: ',bname(j),anname(j)
<      +        ,dname(j)
<       enddo
< 
< cadl write initial.xyz
< c determine optimum strucures' filenames and open files
< c reac
<       write (26,*) 'Getting reactant structure file name'
<       open (unit=57,status='scratch')
<       write(57,1201)iopt_reac
<       rewind (57)
<       read (57,'(A40)') filename
<       write (26,*) 'Filename is ',filename
<       close (unit=57)
<       open (unit=60,file=filename,status='unknown')
< c prod 
<       write (26,*) 'Getting product structure file name'
<       open (unit=58,status='scratch')
<       write(58,1202)iopt_prod
<       write(26,*)iopt_prod
<       rewind (58)
<       read (58,'(A40)') filename
<       write (26,*) 'Filename is ',filename
<       close (unit=58)
<       open (unit=61,file=filename,status='unknown')
< c open file to write xyz
<       open (unit=59,file='./initial0001.xyz',status='unknown')
< cadl nice code to write initial but 2nd line must be empty!
<       ! leof = .FALSE.
<       ! do while (leof.eqv..FALSE.)
<       !    read(60,'(A70)') comline1
<       !    if (comline1.EQ.'') then
<       !       leof = .TRUE.
<       !    else
<       !       write(59,*) comline1
<       !    endif
<       ! enddo
<       ! close(60)
<       ! leof = .FALSE.
<       ! do while (leof.eqv..FALSE.)
<       !    read(61,'(A70)') comline1
<       !    if (comline1.EQ.'') then
<       !       leof = .TRUE.
<       !    else
<       !       write(59,*) comline1
<       !    endif
<       ! enddo
<       ! close(61)
<       ! close(59)
< 
< cadl Write xyz of reac1
<       write(59,*) natom1
<       write(59,*) 'blank'
<       read (60,*)
<       read (60,*)
<       do iatom = 1, natom1
<          read (60,'(A70)') copystuff
<          write(59,*) copystuff
<       enddo
<       rewind (60)
<       close (60)
< c write xyz of prod1
<       write (59,*) natom1
<       write (59,*) 'blank'
<       read (61,*)
<       read (61,*)
<       do iatom = 1, natom1
<          read (61,'(A70)') copystuff
<          write(59,*) copystuff
<       enddo
<       rewind (61)
<       close (61)
<       close (unit=59)
<       write (26,*) 'Written initial0001.xyz file'
< 
< cadl Write input file
< cadl check if inpfileq.dat exist in data, otherwise write default
<       irestt = 0
<       imaxopt = 80
<       istepopt = 30
<       zconv = 0.0005
<       znodetol = 0.1
<       zscal=1.0
<       zssmdqmax=0.8
<       igrowth = 0
<       zintthresh = 2.0
<       zminspace = 5.0
<       ibondfrag = 1
<       initopt = 0
<       ifinopt = 150
<       zprodlim = 200
<       itstype = 1
<       inodes = 11        
<       inquire(file='data/inpfileq.dat',EXIST=ex)
<       if (ex) then
<          open (unit=59,file='data/inpfileq.dat',status='unknown')
<          do while (WORD.NE.'END')
<             call LineRead (59)
<             if (WORD.EQ.'RESTART') then
<                read (59,*) irestt,imaxopt,istepopt
<             elseif (WORD.EQ.'CONV_TOL') then
<                read (59,*) zconv,znodetol,zscal,zssmdqmax
<             elseif (WORD.EQ.'GROWTH_DIRECTION') then
<                read (59,*) igrowth
<             elseif (WORD.EQ.'INT_THRESH') then
<                read (59,*) zintthresh,zminspace,ibondfrag
<             elseif (WORD.EQ.'INITIAL_OPT') then
<                read (59,*) initopt,ifinopt
<             elseif (WORD.EQ.'PRODUCT_LIMIT') then
<                read (59,*) zprodlim
<             elseif (WORD.EQ.'TS_FINAL_TYPE') then
<                read (59,*) itstype
<             elseif (WORD.EQ.'NNODES') then
<                read (59,*) inodes
<             endif
<          enddo
<          close (59) 
<       endif
<       open (unit=59,file='./inpfileq',status='unknown')
<       write (59,*) '# FSM/GSM/SSM inpfileq'
<       write (59,*)
<       write (59,*) '------------ String Info -------------------------'
<       write (59,*) 'SM_TYPE           GSM    # SSM, FSM or GSM'
<       write (59,*) 'RESTART    ',irestt      
<       write (59,*) 'MAX_OPT_ITERS    ',imaxopt    
<       write (59,*) 'STEP_OPT_ITERS   ',istepopt
<       write (59,*) 'CONV_TOL        ',zconv
<       write (59,*) 'ADD_NODE_TOL   ',znodetol
<       write (59,*) 'SCALING     ',zscal
<       write (59,*) 'SSM_DQMAX    ',zssmdqmax
<       write (59,*) 'GROWTH_DIRECTION  ',igrowth
<       write (59,*) 'INT_THRESH     ',zintthresh
<       write (59,*) 'MIN_SPACING   ',zminspace
<       write (59,*) 'BOND_FRAGMENTS   ',ibondfrag
<       write (59,*) 'INITIAL_OPT    ',initopt
<       write (59,*) 'FINAL_OPT    ',ifinopt
<       write (59,*) 'PRODUCT_LIMIT   ',zprodlim
<       write (59,*) 'TS_FINAL_TYPE    ',itstype
<       write (59,*) 'NNODES   ',inodes
<       write (59,*) '--------------------------------------------------'
<       close (59)
<       write (26,*) 'Written inpfileq file'
<  
< cadl start calculation
<       command1='mkdir -p ./scratch'
<       call commrun(command1)
<       command1='cp initial0001.xyz scratch/initial0001.xyz'
<       call commrun(command1)
<       write(26,*) 'Starting GSM calculation now...'
<       command1='gfstringq.exe 1 16 > stdout_gsm0001.out'
<       call commrun(command1)
<       command1='rm scratch/*chk'
<       call commrun(command1)
< 
< cadl copy everything into gsm/ and interesting stuff into output
<       command1='mkdir -p ./gsm'
<       call commrun(command1)
<       command1='mkdir -p ./gsm/scratch'
<       call commrun(command1)
<       command1='mv inpfileq gstart initial0001.xyz ./gsm/'
<       call commrun(command1)
<       command1='mv  stringfile.xyz0001 stringfile.xyz0001fr ./gsm/'
<       call commrun(command1)
<       command1='cp  ./scratch/tsq0001.xyz ./geoms/ts_gsm.xyz'
<       call commrun(command1)
<       command1='mv ./scratch/* ./gsm/scratch/'
<       call commrun(command1)
<       command1='rm -rf ./scratch'
<       call commrun(command1)
<       command1='cp  stdout_gsm0001.out ./output/ts_gsm.out'
<       call commrun(command1)
<       command1='mv  stdout_gsm0001.out ./gsm/'
<       call commrun(command1)
<       write (26,*) 'Done :)'
< 
< cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
< cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
< c POST PROCESSING
< cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
< cadl Convert xyz into zmatrix for further calculations
< c inspiration and usage of xyz_to_zmat
<       open (unit=59,file='./geoms/ts_gsm.xyz',status='unknown')
<       read (59,*) natom1
<       read (59,*)
< c cycle on atoms and call subroutine for each line
< c need to save xyz coords somewhere, use coord(natommx,ndim)
<       do k=1,natom1
<          read (59,*)cjunk,coord(k,1),coord(k,2),coord(k,3)
< c         write (26,*) cjunk,coord(k,1),coord(k,2),coord(k,3)
<       enddo
<       close (unit=59)
< 
< c cycle on atoms, read connectivity from ibconn,iaconn and idconn 
< c and run subroutine to convert xyz to zmat for one line
<       open (unit=59,file='./output/grid_opt.out',status='unknown')
<       write (59,*) 'grid is the word I am looking for'
<       do iatom=1,natomt1
<          if (iatom.EQ.1) then
<             write (26,*) iatom
< c            write (59,*) atomlabel(iatom)
< 
<          else if (iatom.EQ.2) then
<             open (unit=64,status='scratch')
<             write (64,*) atomlabel(iatom)
<             rewind(64)
<             read (64,*) ct1,ct2,ct3
<             rewind(64)
<             close (64)
<             do j=1,ncoord
<                write (26,*) 'Vediamo che fa: ', intcoor(j), ct3
<                if (intcoor(j).EQ.ct3) idist=j
<             enddo
<             xa=coord(iatom,1)
<             ya=coord(iatom,2)
<             za=coord(iatom,3)
<             xb=coord(ibconn(iatom),1)
<             yb=coord(ibconn(iatom),2)
<             zb=coord(ibconn(iatom),3)
<             dist=sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb)+
<      $      (za-zb)*(za-zb))
<             xints(idist)=dist
<             write (26,*) iatom,dist
< c            write (59,*) atomlabel(iatom)
<             xints(idist)=dist
<          
<          else if (iatom.EQ.3) then
<             open (unit=64,status='scratch')
<             write (64,*) atomlabel(iatom)
<             rewind(64)
<             read (64,*) ct1,ct2,ct3,ct4,ct5
<             rewind(64)
<             close (64)
<             do j=1,ncoord
<                if (intcoor(j).EQ.ct3) idist=j
<                if (intcoor(j).EQ.ct5) iang=j
<             enddo
<             xa=coord(iatom,1)
<             ya=coord(iatom,2)
<             za=coord(iatom,3)
<             xb=coord(ibconn(iatom),1)
<             yb=coord(ibconn(iatom),2)
<             zb=coord(ibconn(iatom),3)
<             xc=coord(iaconn(iatom),1)
<             yc=coord(iaconn(iatom),2)
<             zc=coord(iaconn(iatom),3)
<             dist=sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb)+
<      $      (za-zb)*(za-zb))
< c repeat one atom, only care about planar angle here
<             call xyz_to_zmat(xa,ya,za,xb,yb,zb,
<      $      xc,yc,zc,xc,yc,zc,ang,dihed)
<             write (26,*) iatom,dist,ang
< c            write (59,*) atomlabel(iatom) 
<             xints(idist)=dist
<             xints(iang)=ang
< 
<          else
<             open (unit=64,status='scratch')
<             write (64,*) atomlabel(iatom)
<             rewind(64)
<             read (64,*) ct1,ct2,ct3,ct4,ct5,ct6,ct7
<             rewind(64)
<             close (64)
<             do j=1,ncoord
<                if (intcoor(j).EQ.ct3) idist=j
<                if (intcoor(j).EQ.ct5) iang=j
<                if (intcoor(j).EQ.ct7) idih=j
<             enddo
<             xa=coord(iatom,1)
<             ya=coord(iatom,2)
<             za=coord(iatom,3)
<             xb=coord(ibconn(iatom),1)
<             yb=coord(ibconn(iatom),2)
<             zb=coord(ibconn(iatom),3)
<             xc=coord(iaconn(iatom),1)
<             yc=coord(iaconn(iatom),2)
<             zc=coord(iaconn(iatom),3)
<             xd=coord(idconn(iatom),1)
<             yd=coord(idconn(iatom),2)
<             zd=coord(idconn(iatom),3)
<             dist=sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb)+
<      $      (za-zb)*(za-zb))
<             call xyz_to_zmat(xa,ya,za,xb,yb,zb,
<      $      xc,yc,zc,xd,yd,zd,ang,dihed)
<             write (26,*) iatom,dist,ang,dihed
< c            write (59,*) atomlabel(iatom)
<             xints(idist)=dist
<             xints(iang)=ang
<             xints(idih)=dihed
<          endif
<       enddo
< 
< c funziona ma non modifico connettività di ireact ad ora
< c modifico la riga di ireact
<       if (ireact.EQ.3) then
<          open (unit=64,status='scratch')
<          write (64,*) atomlabel(ireact)
<          rewind(64)
<          read (64,*) ct1,ct2,ct3,ct4,ct5
<          rewind(64)
<          close (64)
<          do j=1,ncoord
<             if (intcoor(j).EQ.ct3) idist=j
<             if (intcoor(j).EQ.ct5) iang=j
<          enddo
<          intcoor(idist)='RTS'
<          intcoor(iang)='AABS'
<          ct3='RTS'
<          ct5='AABS'
<          xa=coord(ireact,1)
<          ya=coord(ireact,2)
<          za=coord(ireact,3)
<          xb=coord(isite,1)
<          yb=coord(isite,2)
<          zb=coord(isite,3)
<          xc=coord(jsite,1)
<          yc=coord(jsite,2)
<          zc=coord(jsite,3)
< c repeat one atom, only care about planar angle here    
<          xd=coord(jsite,1)
<          yd=coord(jsite,2)
<          zd=coord(jsite,3)
<          dist=sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb)+
<      $      (za-zb)*(za-zb))
<          call xyz_to_zmat(xa,ya,za,xb,yb,zb,
<      $      xc,yc,zc,xd,yd,zd,ang,dihed)
<          xints(idist)=dist
<          xints(iang)=ang
<          open (unit=64,status='scratch')
<          write (64,*) ct1,atname(isite),ct3,atname(jsite),ct5
<          rewind(64)
<          read (64,*) ct1,ct2,ct3,ct4,ct5
<          close (64)
<          atomlabel(ireact)=ct1//ct2//ct3//ct4//ct5
<          write (26,*) ireact,dist,ang
<       else
<          open (unit=64,status='scratch')
<          write (64,*) atomlabel(ireact)
<          rewind(64)
<          read (64,*) ct1,ct2,ct3,ct4,ct5,ct6,ct7
<          rewind(64)
<          close (64)
<          do j=1,ncoord
<             if (intcoor(j).EQ.ct3) idist=j
<             if (intcoor(j).EQ.ct5) iang=j
<             if (intcoor(j).EQ.ct7) idih=j
<          enddo
<          intcoor(idist)='RTS'
<          intcoor(iang)='AABS'
<          intcoor(idih)='BABS'
<          ct3='RTS'
<          ct5='AABS'
<          ct7='BABS'
<          xa=coord(ireact,1)
<          ya=coord(ireact,2)
<          za=coord(ireact,3)
<          xb=coord(isite,1)
<          yb=coord(isite,2)
<          zb=coord(isite,3)
<          xc=coord(jsite,1)
<          yc=coord(jsite,2)
<          zc=coord(jsite,3)
<          xd=coord(ksite,1)
<          yd=coord(ksite,2)
<          zd=coord(ksite,3)
<          dist=sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb)+
<      $      (za-zb)*(za-zb))
<          call xyz_to_zmat(xa,ya,za,xb,yb,zb,
<      $      xc,yc,zc,xd,yd,zd,ang,dihed)
<          xints(idist)=dist
<          xints(iang)=ang
<          xints(idih)=dihed
<          open (unit=64,status='scratch')
<          write (64,*) ct1,atname(isite),ct3,atname(jsite),ct5,
<      $      atname(ksite),ct7
<          rewind(64)
<          read (64,*) ct1,ct2,ct3,ct4,ct5,ct6,ct7
<          close (64)
<          atomlabel(ireact)=ct1//ct2//ct3//ct4//ct5//ct6//ct7
<          write (26,*) ireact,dist,ang,dihed
<       endif
< 
< cadl Save data in grid_opt.out in order to make it readable to ts_0
<       do iatom=1,natom
<          write (59,*) atomlabel(iatom)
<       enddo
<       do iint=1,ncoord
<          write(59,*) intcoor(iint),xints(iint)
<       enddo
<       close (unit=59)
< 
< cadl report info in gsm_opt.out
<       write (26,*)
<       do iatom=1,natom1
<          write (26,*) atomlabel(iatom)
<       enddo
<       do iint=1,ncoord
<          write (26,*) intcoor(iint),xints(iint)
<       enddo
< 
<       close (unit=26,status='keep')
< 
<  1201 format ("./geoms/reac1_"I0.2".xyz")
<  1202 format ("./geoms/prod1_"I0.2".xyz")
< 
<       return
<       end
< 
< cadl End Modified part
< cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
< 
< cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
< cadl Call to single ended gsm method
< cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
<       subroutine ssm_opt_iso
< 
<       implicit double precision (a-h,o-z)
<       implicit integer (i-n)
< 
<       include 'data_estoktp.fi'
<       include 'param_estoktp.fi'
< 
<       dimension tau(ntaumx),taumn(ntaumx),taumx(ntaumx),freq(nmdmx)
<       dimension coord(natommx,ndim),xint(3*natommx),xinti(3*natommx),
<      $ abcrot(ndim)
<       dimension xints(3*natommx)
<       dimension tauopt(ntaumx)
<       dimension drea(noptmx)
< 
<       character*70 comline1,comline2,copystuff
<       character*60 atomlabel(natommx)
<       character*60 atomlabel1(natommx)
<       character*30 intcoor(3*natommx)
<       character*30 intcoors(3*natommx)
<       character*20 bislab(ntaumx)
<       character*30 gmem
<       character*70 command1
<       character*40 filename
<       character*4  cjunk
<       character*100 commandcopy
<       character*30 dih_rot
< 
<       LOGICAL leof,lsec,ltit,ex
< 
<       CHARACTER*1000 line,string
<       CHARACTER*160 sename,word,word2,word3,title,title1,
<      $ word4,word5,word6,word7
< 
< cadl Things necessary to play with zmat_routines
<       dimension ibconn(natommx),iaconn(natommx),idconn(natommx)
<       dimension idummy(natommx)
< c      character*60 atomlabel(natommx)
< c      character*30 intcoor(3*natommx)
< c      character*20 bislab(ntaumx)
<       character*20 bname(natommx),anname(natommx),dname(natommx)
<      $ ,atname(natommx),bconnt(natommx),aconnt(natommx),dconnt(natommx)
<       character*1 xread
<       character*5 ccheck
< c      LOGICAL leof,lsec,ltit
< c      CHARACTER*1000 line,string
< c      CHARACTER*160 sename,word,word2,word3
< c     $ ,title,title1,word4,word5,word6,word7
<       character*6 ct1,ct2,ct3,ct4,ct5,ct6,ct7
< c      include 'filcomm.f'
< 
<       include 'filcomm.f'
< 
< cc parameter initialization
<       ires=1
<       ireac_geom=0
<       iaspace=0
< 
< c input data
<       open (unit=25,file='./data/ts.dat',status='old')
<       open (unit=26,file='./output/gsm_opt.out',status='unknown')
<       open (unit=21,file='./data/theory.dat',status='unknown')
< 
< cadl Reads info from ts.dat
< c check if info is given to write isomers file ADDED KEYWORDS
<       iadd=1
<       ibreak=1
<       inumbond=1
<       iang=1
<       itor=1
<       do while (WORD.NE.'ADD')
<          call LineRead (25)
<          if (WORD.EQ.'END') then
<             write (26,*) 'no add keword found'
<             iadd=0
<             exit
<          endif
<       enddo
<       if (iadd.NE.0) then
<          open (unit=57,file='addedbonds.tmp',status='unknown')
<          read (25,*) iadded
<          do j=1,iadded
<             read (25,*) ct1,ct2 
<             write (57,*) ct1,ct2 
<             write (26,*) 'Bond to be added: ', ct1,ct2 
<          enddo
<          rewind (57)
<          close (57)
<       endif
<       rewind (25)
<       
<       do while (WORD.NE.'BREAK')
<          call LineRead (25)
<          if (WORD.EQ.'END') then
<             write (26,*) 'no break keword found'
<             ibreak=0
<             exit
<          endif
<       enddo
<       if (ibreak.NE.0) then
<          open (unit=58,file='brokenbonds.tmp',status='unknown')
<          read (25,*) ibroken
<          do j=1,ibroken
<             read (25,*) ct1,ct2  
<             write (58,*) ct1,ct2 
<             write (26,*) 'Bond to be broken: ', ct1,ct2 
<          enddo
<          rewind (58)
<          close (58)
<       endif
<       rewind (25)
< 
<       do while (WORD.NE.'BOND')
<          call LineRead (25)
<          if (WORD.EQ.'END') then
<             write (26,*) 'no BOND keword found'
<             inumbond=0
<             exit
<          endif
<       enddo
<       if (inumbond.NE.0) then
<          open (unit=58,file='bond.tmp',status='unknown')
<          read (25,*) numbonds
<          do j=1,numbonds
<             read (25,*) ct1,ct2,zbond  
<             write (58,*) ct1,ct2,zbond 
<             write (26,*) 'Bond - goes to: ', ct1,ct2,zbond
<          enddo
<          rewind (58)
<          close (58)
<       endif
<       rewind (25)
< 
<       do while (WORD.NE.'ANGLE')
<          call LineRead (25)
<          if (WORD.EQ.'END') then
<             write (26,*) 'no ANGLE keword found'
<             iang=0
<             exit
<          endif
<       enddo
<       if (iang.NE.0) then
<          open (unit=58,file='angle.tmp',status='unknown')
<          read (25,*) nang
<          do j=1,nang
<             read (25,*) ct1,ct2,ct3,zang 
<             write (58,*) ct1,ct2,ct3,zang 
<             write (26,*) 'Angle - goes to: ', ct1,ct2,ct3,zang
<          enddo
<          rewind (58)
<          close (58)
<       endif
<       rewind (25)
< 
<       do while (WORD.NE.'TORSION')
<          call LineRead (25)
<          if (WORD.EQ.'END') then
<             write (26,*) 'no TORSION keword found'
<             itor=0
<             exit
<          endif
<       enddo
<       if (itor.NE.0) then
<          open (unit=58,file='torsion.tmp',status='unknown')
<          read (25,*) ntors
<          do j=1,ntors
<             read (25,*) ct1,ct2,ct3,ct4,ztor  
<             write (58,*) ct1,ct2,ct3,ct4,ztor 
<             write (26,*) 'Torsion - goes to: ', ct1,ct2,ct3,ct4,ztor
<          enddo
<          rewind (58)
<          close (58)
<       endif
<       rewind (25)
< 
< c read charge and spin
<       do while (WORD.NE.'CHARGE')
<          call LineRead (25)
<          if (WORD.EQ.'END') then
<             write (26,*) 'charge and spin must be defined'
<             stop
<          endif
<       enddo
<       read (25,*) icharge,ispin
<       rewind (25)
<       write (26,*) 'Read TS charge and spin: ',icharge,ispin
< c read isite jsite ksite
<       do while (WORD.NE.'ISITE')
<          call LineRead (25)
<          if (WORD.EQ.'END') then
<             write (26,*) 'reaction site must be defined'
<             stop
<          endif
<       enddo
<       read (25,*) isite,jsite,ksite
<       rewind (25)
<       write (26,*) 'Read i,j,k sites: ',isite,jsite,ksite
< c reads rmin, just need ireact!
<       do while (WORD.NE.'RMIN1')
<          call LineRead (25)
<          if (WORD.EQ.'END') then
<             write (26,*) 'grid coords must be defined'
<             stop
<          endif
<       enddo
<       read (25,*) cjunk,cjunk,cjunk,cjunk,ireact
<       rewind (25)
<       write (26,*) 'Read ireact: ',ireact
< c checks if user asks to use particular reac_geom ADDED KEYOWORD!
<       do while (WORD.NE.'REAC_GEOM')
<          call LineRead (25)
<          if (WORD.EQ.'END') then
<             rewind(25)
<             goto 999
<          endif
<       enddo
<       read (25,*) ireac_geom
<       write (26,*) 'It is requested to use reac_geom n. ',ireac_geom
<  999  continue
<       rewind(25)
<       close (25)
< 
< cadl Get number of atoms from reac1.dat
<       open (unit=15,file='./data/reac1.dat',status='old')
< c get atom number, doesn't care for dummy so natomt1 not used
< c for now. Will have to account for it going back to zmat maybe?      
<       do while (WORD.NE.'NATOM')
<          call LineRead (15)
<          if (WORD.EQ.'END') then
<             write (26,*) 'natom must be defined'
<             stop
<          endif
<       enddo
<       read (15,*) natom1,natomt1
<       rewind (15)
<       close (15)
<       natom=natom1
<       natomt=natomt1
< 
< cadl Choose reactant structure for calculation
< c first determine how many structures were determined with the rotational scan
<       command1='ls output/reac1_opt_* > temp.log'
<       call commrun(command1)
<       command1='grep -c ^ temp.log > num.log'
<       call commrun(command1)
<       open (unit=99,file='num.log',status='unknown')
<       read (99,*) numstruct_reac
<       close (unit=99,status='keep')
<       write (26,*) 'Read numstruct reac: ',numstruct_reac
<       write (26,*)
< c now open the xyz files and search the one with the minimum distance
< c between the reacting atoms
<       write (26,*) 'Distance between ireact and isite'
<       do j=1,numstruct_reac
<          open (unit=99,status='unknown')
<          write(99,1201)j
<          rewind (99)
<          read (99,'(A40)') filename
<          close (99)
<          write(26,*) 'filename is ',filename
<          open(unit=23,file=filename,status='unknown')
<          read (23,*)
<          read (23,*)
<          do k=1,natom1
<             read (23,*)cjunk,coox,cooy,cooz
<             if(k.EQ.ireact)then
<                coox1=coox
<                cooy1=cooy
<                cooz1=cooz
<             endif
<             if(k.EQ.isite)then
<                coox2=coox
<                cooy2=cooy
<                cooz2=cooz
<             endif
<          enddo
<          close(23)
<          drea(j)=sqrt((coox1-coox2)**2+(cooy1-cooy2)**2
<      $           +(cooz1-cooz2)**2)
<          write(26,*)'irea-isite dist for str ',j,' is ',drea(j)
<       enddo
< c now determine the reac structure with the minimum distance
<       iopt_reac=1
<       do j=1,numstruct_reac
<          if(drea(j).LT.drea(iopt_reac))then
<             iopt_reac=j
<          endif
<       enddo
<       write(26,*) 'the structure with the min dist is',iopt_reac
<       if (ireac_geom.NE.0)then 
<          iopt_reac=ireac_geom
<          write(26,*) 'forced from ts.dat the use of geom ',iopt_reac
<       endif
<       write (26,*)
< 
< cadl Funzione di restart da valutare e capire se si può fare
< c Level of theory
<       write (26,*) 'LOT'
<       do while (WORD.NE.'LEVEL0_TS')
<          call LineRead (21)
<          if (WORD.EQ.'END') then
<             write (26,*) 'gaussian level0 of theory must be defined'
<             write (26,*) 'in file theory.dat'
<             stop
<          endif
<       enddo
<       if (word2.EQ.'G09') then
<          ilev0code=1
<       else
<          write (26,*) 'level0 of theory must be'
<          write (26,*) 'only g09 in theory.dat'
<          stop
<       endif
<       ! if(word3.eq.'RESTART') then
<       !    open (unit=99,status='unknown')
<       !    write (99,*) word4
<       !    rewind (99)
<       !    read (99,*) ires
<       !    close (unit=99,status='keep')
<       ! endif
<       if (ilev0code.eq.1) then
<          read (21,'(A70)') comline1
<       endif
<       close (21)
<       k=3
<       do while (comline1(k:k).NE.' ')
<          k=k+1
<       enddo
<       write (26,*) 'Level of theory: '//comline1(:k)
< 
< cadl Write gstart file (g09 lot)
<       open (unit=59,file='./gstart',status='unknown')
<       write (59,*) '# '//comline1(:k)//' nosymm '//'Force '//'test'
<       write (59,*)
<       write (59,*) 'Title Card Required'
<       write (59,*)
<       write (59,*) icharge,ispin
<       close (59)
<       write (26,*)
<       write (26,*) 'Writing input files:'
<       write (26,*) 'Written gstart file'
< 
< cadl Write ISOMERS file and get info on zmatrix
< c need to account for scanned dihedrals
< c get number of internal coordinates
<       ncoord = 3*natom1-6
< c get connectivity of ireact in reac1
<       write (26,*) 'natom1, ncoord',natom1,ncoord
<       open (unit=15,file='./data/reac1.dat',status='old')
< c define ntau1
<       do while (WORD.NE.'NTAU')
<          call LineRead (15)
<          if (WORD.EQ.'END') then
<             write (6,*) 'sampling coordinates of reac1 must be defined'
<             stop
<          endif
<       enddo
<       read (15,*) ntau1
<       read (15,*)
<       if (ntau1.NE.0) then
<          do iint=1,ntau1
<             read (15,*) intcoor(ncoord-ntau1+iint),
<      $                  xint(ncoord-ntau1+iint),cjunk
< c            write(26,*) 'What reading?', intcoor(ncoord-ntau1+iint),
< c     $                  xint(ncoord-ntau1+iint)
<          enddo
<       endif
<       rewind (15)
< c  reading z-mat
<       do while (WORD.NE.'CHARGE')
<          call LineRead (15)  
<       enddo
<       call LineRead (15)
<       if (idebug.GE.2) write (26,*) 'reading z-mat input'
<       do iatom = 1 , natomt1
<          read (15,'(A60)') atomlabel(iatom)
< c         write (26,*) atomlabel(iatom)
<       enddo
< c read coordinate names
<       call LineRead (15)
<       do iint = 1 , ncoord-ntau1
<          read (15,*) intcoor(iint),xint(iint)
<       enddo
< c      do iint = 1 , ncoord
< c         write (26,*) 'intcoor, xint ',intcoor(iint),xint(iint)
< c      enddo
<       close (15)
< 
<       call read_zmat(atomlabel,natom1,natomt1,intcoor,bislab,ibconn,
<      $ iaconn,idconn,bname,anname,dname,atname,idummy,isited,jsited,
<      $ ksited,bconnt,aconnt,dconnt)
<       write (26,*)
<       write (26,*) 'Reading zmatrix connectivity:'
<       do j=1,natomt1
<          write (26,*)'at ',j,' conn is: ',ibconn(j),iaconn(j),idconn(j)
<       enddo
<       do j=1,natomt1
<          write (26,*)'at ',j,'bond ang dihed are: ',bname(j),anname(j)
<      +        ,dname(j)
<       enddo
< 
<       open (unit=59,file='./ISOMERS0001',status='unknown')
< 
<       write (59,*) 'NEW'
<       if (iadd.EQ.0) then
<          write (59,*) 'ADD ',isite,ireact
<       else
<          open (unit=57,file='addedbonds.tmp',status='unknown')
<          do j=1,iadded
<             read(57,*) ct1,ct2
<             write (59,*) 'ADD ',ct1,ct2
<          enddo
<          close (57)
<       endif
<       if (ibreak.EQ.0) then
<       write (59,*) 'BREAK ',ibconn(ireact),ireact
<       else
<          open (unit=58,file='brokenbonds.tmp',status='unknown')
<          do j=1,ibroken
<             read(58,*) ct1,ct2
<             write (59,*) 'BREAK ',ct1,ct2
<          enddo
<          close (58)
<       endif
< 
<       if (inumbond.EQ.1) then
<          open (unit=58,file='bond.tmp',status='unknown')
<          do j=1,numbonds
<             read(58,*) ct1,ct2,zbond
<             write (59,*) 'BOND ',ct1,ct2,zbond
<          enddo
<          close (58)
<       endif
< 
<       if (iang.EQ.1) then
<          open (unit=58,file='angle.tmp',status='unknown')
<          do j=1,nang
<             read(58,*) ct1,ct2,ct3,zang
<             write (59,*) 'ANGLE ',ct1,ct2,ct3,zang
<          enddo
<          close (58)
<       endif
< 
<       if (itor.EQ.1) then
<          open (unit=58,file='torsion.tmp',status='unknown')
<          do j=1,nang
<             read(58,*) ct1,ct2,ct3,ct4,ztor
<             write (59,*) 'ANGLE ',ct1,ct2,ct3,ct4,ztor
<          enddo
<          close (58)
<       endif
< 
<       close (59)
< 
< cadl Write initial.xyz
< c determine optimum reac' filenames and open file
<       write (26,*)
<       write (26,*) 'Getting reactant structure file name:'
<       open (unit=57,status='scratch')
<       write(57,1201)iopt_reac
<       rewind (57)
<       read (57,'(A40)') filename
<       write (26,*) 'Filename is ',filename
<       close (unit=57)
<       open (unit=60,file=filename,status='unknown')
< c open file to write xyz
<       open (unit=59,file='./initial0001.xyz',status='unknown')
< c write xyz of reac1
<       write(59,*) natom1
<       write(59,*) 'blank'
<       read (60,*)
<       read (60,*)
<       do iatom = 1, natom1
<          read (60,'(A70)') copystuff
<          write(59,*) copystuff
<       enddo
<       rewind (60)
<       close (60)
<       close (unit=59)
<       write (26,*) 'Written initial0001.xyz file'
< 
< cadl Write input file
< cadl check if inpfileq.dat exist in data, otherwise write default
<       irestt = 0
<       imaxopt = 80
<       istepopt = 30
<       zconv = 0.0005
<       znodetol = 0.1
<       zscal=1.0
<       zssmdqmax=0.8
<       igrowth = 0
<       zintthresh = 2.0
<       zminspace = 5.0
<       ibondfrag = 1
<       initopt = 0
<       ifinopt = 150
<       zprodlim = 200
<       itstype = 1
<       inodes = 27        
<       inquire(file='data/inpfileq.dat',EXIST=ex)
<       if (ex) then
<          open (unit=59,file='data/inpfileq.dat',status='unknown')
<          do while (WORD.NE.'END')
<             call LineRead (59)
<             if (WORD.EQ.'RESTART') then
<                read (59,*) irestt,imaxopt,istepopt
<             elseif (WORD.EQ.'CONV_TOL') then
<                read (59,*) zconv,znodetol,zscal,zssmdqmax
<             elseif (WORD.EQ.'GROWTH_DIRECTION') then
<                read (59,*) igrowth
<             elseif (WORD.EQ.'INT_THRESH') then
<                read (59,*) zintthresh,zminspace,ibondfrag
<             elseif (WORD.EQ.'INITIAL_OPT') then
<                read (59,*) initopt,ifinopt
<             elseif (WORD.EQ.'PRODUCT_LIMIT') then
<                read (59,*) zprodlim
<             elseif (WORD.EQ.'TS_FINAL_TYPE') then
<                read (59,*) itstype
<             elseif (WORD.EQ.'NNODES') then
<                read (59,*) inodes
<             endif
<          enddo
<          close (59) 
<       endif
<       open (unit=59,file='./inpfileq',status='unknown')
<       write (59,*) '# FSM/GSM/SSM inpfileq'
<       write (59,*)
<       write (59,*) '------------ String Info -------------------------'
<       write (59,*) 'SM_TYPE           SSM    # SSM, FSM or GSM'
<       write (59,*) 'RESTART    ',irestt      
<       write (59,*) 'MAX_OPT_ITERS    ',imaxopt    
<       write (59,*) 'STEP_OPT_ITERS   ',istepopt
<       write (59,*) 'CONV_TOL        ',zconv
<       write (59,*) 'ADD_NODE_TOL   ',znodetol
<       write (59,*) 'SCALING     ',zscal
<       write (59,*) 'SSM_DQMAX    ',zssmdqmax
<       write (59,*) 'GROWTH_DIRECTION  ',igrowth
<       write (59,*) 'INT_THRESH     ',zintthresh
<       write (59,*) 'MIN_SPACING   ',zminspace
<       write (59,*) 'BOND_FRAGMENTS   ',ibondfrag
<       write (59,*) 'INITIAL_OPT    ',initopt
<       write (59,*) 'FINAL_OPT    ',ifinopt
<       write (59,*) 'PRODUCT_LIMIT   ',zprodlim
<       write (59,*) 'TS_FINAL_TYPE    ',itstype
<       write (59,*) 'NNODES   ',inodes
<       write (59,*) '--------------------------------------------------'
<       close (59)
<       write (26,*) 'Written inpfileq file'
< 
< cadl Start calculation
<         command1='mkdir -p ./scratch'
<         call commrun(command1)
<         command1='cp initial0001.xyz scratch/initial0001.xyz'
<         call commrun(command1)
<         write(26,*) 'Starting SSM calculation now...'
<         command1='gfstringq.exe 1 16 > stdout_gsm0001.out'
<         call commrun(command1)
<         command1='rm scratch/*chk'
<         call commrun(command1)
<         command1='rm addedbonds.tmp brokenbonds.tmp'
<         call commrun(command1)
< 
< cadl Copy everything into gsm/ and interesting stuff into output
<         command1='mkdir -p ./gsm'
<         call commrun(command1)
<         command1='mkdir -p ./gsm/scratch'
<         call commrun(command1)
<         command1='mv inpfileq gstart initial0001.xyz ISOMERS0001 ./gsm/'
<         call commrun(command1)
<         command1='mv  stringfile.xyz0001 stringfile.xyz0001fr ./gsm/'
<         call commrun(command1)
<         command1='cp  ./scratch/tsq0001.xyz ./geoms/ts_gsm.xyz'
<         call commrun(command1)
<         command1='mv ./scratch/* ./gsm/scratch/'
<         call commrun(command1)
<         command1='rm -rf ./scratch'
<         call commrun(command1)
<         command1='cp  stdout_gsm0001.out ./output/ts_gsm.out'
<         call commrun(command1)
<         command1='mv  stdout_gsm0001.out ./gsm/'
<         call commrun(command1)
<         write (26,*) 'Done :)'
< 
< cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
< cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
< c POST PROCESSING
< cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
< cadl Convert xyz into zmatrix for further calculations
< c inspiration and usage of xyz_to_zmat
<       open (unit=59,file='./geoms/ts_gsm.xyz',status='unknown')
<       read (59,*) natom1
<       read (59,*)
< c cycle on atoms and call subroutine for each line
< c need to save xyz coords somewhere, use coord(natommx,ndim)
<       do k=1,natom1
<          read (59,*)cjunk,coord(k,1),coord(k,2),coord(k,3)
< c         write (26,*) cjunk,coord(k,1),coord(k,2),coord(k,3)
<       enddo
<       close (unit=59)
< 
< c cycle on atoms, read connectivity from ibconn,iaconn and idconn 
< c and run subroutine to convert xyz to zmat for one line
<       open (unit=59,file='./output/grid_opt.out',status='unknown')
<       write (59,*) 'grid is the word I am looking for'
<       do iatom=1,natomt1
<          if (iatom.EQ.1) then
<             write (26,*) iatom
< c            write (59,*) atomlabel(iatom)
< 
<          else if (iatom.EQ.2) then
<             open (unit=64,status='scratch')
<             write (64,*) atomlabel(iatom)
<             rewind(64)
<             read (64,*) ct1,ct2,ct3
<             rewind(64)
<             close (64)
<             do j=1,ncoord
<                write (26,*) 'Vediamo che fa: ', intcoor(j), ct3
<                if (intcoor(j).EQ.ct3) idist=j
<             enddo
<             xa=coord(iatom,1)
<             ya=coord(iatom,2)
<             za=coord(iatom,3)
<             xb=coord(ibconn(iatom),1)
<             yb=coord(ibconn(iatom),2)
<             zb=coord(ibconn(iatom),3)
<             dist=sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb)+
<      $      (za-zb)*(za-zb))
<             xints(idist)=dist
<             write (26,*) iatom,dist
< c            write (59,*) atomlabel(iatom)
<             xints(idist)=dist
<          
<          else if (iatom.EQ.3) then
<             open (unit=64,status='scratch')
<             write (64,*) atomlabel(iatom)
<             rewind(64)
<             read (64,*) ct1,ct2,ct3,ct4,ct5
<             rewind(64)
<             close (64)
<             do j=1,ncoord
<                if (intcoor(j).EQ.ct3) idist=j
<                if (intcoor(j).EQ.ct5) iang=j
<             enddo
<             xa=coord(iatom,1)
<             ya=coord(iatom,2)
<             za=coord(iatom,3)
<             xb=coord(ibconn(iatom),1)
<             yb=coord(ibconn(iatom),2)
<             zb=coord(ibconn(iatom),3)
<             xc=coord(iaconn(iatom),1)
<             yc=coord(iaconn(iatom),2)
<             zc=coord(iaconn(iatom),3)
<             dist=sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb)+
<      $      (za-zb)*(za-zb))
< c repeat one atom, only care about planar angle here
<             call xyz_to_zmat(xa,ya,za,xb,yb,zb,
<      $      xc,yc,zc,xc,yc,zc,ang,dihed)
<             write (26,*) iatom,dist,ang
< c            write (59,*) atomlabel(iatom) 
<             xints(idist)=dist
<             xints(iang)=ang
< 
<          else
<             open (unit=64,status='scratch')
<             write (64,*) atomlabel(iatom)
<             rewind(64)
<             read (64,*) ct1,ct2,ct3,ct4,ct5,ct6,ct7
<             rewind(64)
<             close (64)
<             do j=1,ncoord
<                if (intcoor(j).EQ.ct3) idist=j
<                if (intcoor(j).EQ.ct5) iang=j
<                if (intcoor(j).EQ.ct7) idih=j
<             enddo
<             xa=coord(iatom,1)
<             ya=coord(iatom,2)
<             za=coord(iatom,3)
<             xb=coord(ibconn(iatom),1)
<             yb=coord(ibconn(iatom),2)
<             zb=coord(ibconn(iatom),3)
<             xc=coord(iaconn(iatom),1)
<             yc=coord(iaconn(iatom),2)
<             zc=coord(iaconn(iatom),3)
<             xd=coord(idconn(iatom),1)
<             yd=coord(idconn(iatom),2)
<             zd=coord(idconn(iatom),3)
<             dist=sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb)+
<      $      (za-zb)*(za-zb))
<             call xyz_to_zmat(xa,ya,za,xb,yb,zb,
<      $      xc,yc,zc,xd,yd,zd,ang,dihed)
<             write (26,*) iatom,dist,ang,dihed
< c            write (59,*) atomlabel(iatom)
<             xints(idist)=dist
<             xints(iang)=ang
<             xints(idih)=dihed
<          endif
<       enddo
< 
< c funziona ma non modifico connettività di ireact ad ora
< c modifico la riga di ireact
<       if (ireact.EQ.3) then
<          open (unit=64,status='scratch')
<          write (64,*) atomlabel(ireact)
<          rewind(64)
<          read (64,*) ct1,ct2,ct3,ct4,ct5
<          rewind(64)
<          close (64)
<          do j=1,ncoord
<             if (intcoor(j).EQ.ct3) idist=j
<             if (intcoor(j).EQ.ct5) iang=j
<          enddo
<          intcoor(idist)='RTS'
<          intcoor(iang)='AABS'
<          ct3='RTS'
<          ct5='AABS'
<          xa=coord(ireact,1)
<          ya=coord(ireact,2)
<          za=coord(ireact,3)
<          xb=coord(isite,1)
<          yb=coord(isite,2)
<          zb=coord(isite,3)
<          xc=coord(jsite,1)
<          yc=coord(jsite,2)
<          zc=coord(jsite,3)
< c repeat one atom, only care about planar angle here    
<          xd=coord(jsite,1)
<          yd=coord(jsite,2)
<          zd=coord(jsite,3)
<          dist=sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb)+
<      $      (za-zb)*(za-zb))
<          call xyz_to_zmat(xa,ya,za,xb,yb,zb,
<      $      xc,yc,zc,xd,yd,zd,ang,dihed)
<          xints(idist)=dist
<          xints(iang)=ang
<          open (unit=64,status='scratch')
<          write (64,*) ct1,atname(isite),ct3,atname(jsite),ct5
<          rewind(64)
<          read (64,*) ct1,ct2,ct3,ct4,ct5
<          close (64)
<          atomlabel(ireact)=ct1//ct2//ct3//ct4//ct5
<          write (26,*) ireact,dist,ang
<       else
<          open (unit=64,status='scratch')
<          write (64,*) atomlabel(ireact)
<          rewind(64)
<          read (64,*) ct1,ct2,ct3,ct4,ct5,ct6,ct7
<          rewind(64)
<          close (64)
<          do j=1,ncoord
<             if (intcoor(j).EQ.ct3) idist=j
<             if (intcoor(j).EQ.ct5) iang=j
<             if (intcoor(j).EQ.ct7) idih=j
<          enddo
<          intcoor(idist)='RTS'
<          intcoor(iang)='AABS'
<          intcoor(idih)='BABS'
<          ct3='RTS'
<          ct5='AABS'
<          ct7='BABS'
<          xa=coord(ireact,1)
<          ya=coord(ireact,2)
<          za=coord(ireact,3)
<          xb=coord(isite,1)
<          yb=coord(isite,2)
<          zb=coord(isite,3)
<          xc=coord(jsite,1)
<          yc=coord(jsite,2)
<          zc=coord(jsite,3)
<          xd=coord(ksite,1)
<          yd=coord(ksite,2)
<          zd=coord(ksite,3)
<          dist=sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb)+
<      $      (za-zb)*(za-zb))
<          call xyz_to_zmat(xa,ya,za,xb,yb,zb,
<      $      xc,yc,zc,xd,yd,zd,ang,dihed)
<          xints(idist)=dist
<          xints(iang)=ang
<          xints(idih)=dihed
<          open (unit=64,status='scratch')
<          write (64,*) ct1,atname(isite),ct3,atname(jsite),ct5,
<      $      atname(ksite),ct7
<          rewind(64)
<          read (64,*) ct1,ct2,ct3,ct4,ct5,ct6,ct7
<          close (64)
<          atomlabel(ireact)=ct1//ct2//ct3//ct4//ct5//ct6//ct7
<          write (26,*) ireact,dist,ang,dihed
<       endif
< 
< cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
< c old version 
< cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
< C cadl Convert xyz into zmatrix for further calculations
< C c inspiration and usage of xyz_to_zmat
< C       open (unit=59,file='./geoms/ts_gsm.xyz',status='unknown')
< C       read (59,*) natom1
< C       read (59,*)
< C c cycle on atoms and call subroutine for each line
< C c need to save xyz coords somewhere, use coord(natommx,ndim)
< C       do k=1,natom1
< C          read (59,*)cjunk,coord(k,1),coord(k,2),coord(k,3)
< C c         write (26,*) cjunk,coord(k,1),coord(k,2),coord(k,3)
< C       enddo
< C       close (unit=59)
< C c cycle on atoms, read connectivity from ibconn,iaconn and idconn 
< C c and run subroutine to convert xyz to zmat for one line
< C       open (unit=59,file='./output/grid_opt.out',status='unknown')
< C       write (59,*) 'grid is the word I am looking for'
< C c set up counters to write xints correctly
< C c minus is just a placeholder to know how many dihedrals
< C c are placed at the bottom and helps in correct numbering
< C       k=0
< C       minus=1
< C       do iatom=1,natom1
< C          if (iatom.EQ.1) then
< C             write (26,*) iatom
< C             write (59,*) atomlabel(iatom)
< C          else if (iatom.EQ.2) then
< C             xa=coord(iatom,1)
< C             ya=coord(iatom,2)
< C             za=coord(iatom,3)
< C             xb=coord(ibconn(iatom),1)
< C             yb=coord(ibconn(iatom),2)
< C             zb=coord(ibconn(iatom),3)
< C c            write (26,*) xa,ya,za
< C c            write (26,*) xb,yb,zb
< C             dist=sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb)+
< C      $      (za-zb)*(za-zb))
< C             write (26,*) iatom,dist
< C             write (59,*) atomlabel(iatom)
< C             xints(1)=dist
< C          else if (iatom.EQ.3) then
< C             if (iatom.EQ.ireact) then
< C                xa=coord(iatom,1)
< C                ya=coord(iatom,2)
< C                za=coord(iatom,3)
< C                xb=coord(isite,1)
< C                yb=coord(isite,2)
< C                zb=coord(isite,3)
< C                xc=coord(jsite,1)
< C                yc=coord(jsite,2)
< C                zc=coord(jsite,3)
< C                open (unit=64,status='scratch')
< C                write (64,*) atomlabel(iatom)
< C                rewind(64)
< C                read (64,*) ct1,ct2,ct3,ct4,ct5
< C                rewind(64)
< C c               write (26,*) 'Prova scrittura'
< C c               write (26,*) ct1,ct2,ct3,ct4,ct5
< C c               write (26,*) ct1,ct4,ct3,ct2,ct5
< C                intcoor(2)='RTS'
< C !               write (26,*) 'RTS sbagliato qui',intcoor(iint),ct3
< C                intcoor(3)='AABS1'
< C                atomlabel(iatom)=ct1//ct4//intcoor(2)
< C      $                          //ct2//intcoor(3)
< C                close (64)
< C             else
< C                xa=coord(iatom,1)
< C                ya=coord(iatom,2)
< C                za=coord(iatom,3)
< C                xb=coord(ibconn(iatom),1)
< C                yb=coord(ibconn(iatom),2)
< C                zb=coord(ibconn(iatom),3)
< C                xc=coord(iaconn(iatom),1)
< C                yc=coord(iaconn(iatom),2)
< C                zc=coord(iaconn(iatom),3)
< C             endif
< C             dist=sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb)+
< C      $      (za-zb)*(za-zb))
< C c repeat one atom, only care about planar angle here
< C             call xyz_to_zmat(xa,ya,za,xb,yb,zb,
< C      $      xc,yc,zc,xc,yc,zc,ang,dihed)
< C             write (26,*) iatom,dist,ang
< C             write (59,*) atomlabel(iatom) 
< C             xints(2)=dist
< C             xints(3)=ang 
< C          else
< C cadl Here I tried to change the connectivity of ireact to connect it to 
< C c    i,j,k sites but some work is required to change the atoms; 
< C c    xints doesn't work well anymore
< C c    RTS and ABS1 also go to atom 3 intcoor...
< C             if (iatom.EQ.ireact) then
< C                xa=coord(iatom,1)
< C                ya=coord(iatom,2)
< C                za=coord(iatom,3)
< C                xb=coord(isite,1)
< C                yb=coord(isite,2)
< C                zb=coord(isite,3)
< C                xc=coord(jsite,1)
< C                yc=coord(jsite,2)
< C                zc=coord(jsite,3)
< C                xd=coord(ksite,1)
< C                yd=coord(ksite,2)
< C                zd=coord(ksite,3)
< C                open (unit=64,status='scratch')
< C                write (64,*) atomlabel(iatom)
< C                rewind(64)
< C                read (64,*) ct1,ct2,ct3,ct4,ct5,ct6,ct7
< C                rewind(64)
< C                close (64)
< C c               write (26,*) 'Prova scrittura'
< C c               write (26,*) ct1,ct2,ct3,ct4,ct5,ct6,ct7
< C cadl Maybe to generalize I could write atomlabel(isite) to a scratch
< C c    file, read the first element in ct2, then rewind, write
< C c    atomlabel(jsite) to scratch, read first element in ct4 and so on
< C                do iint=1,ncoord
< C                  if (intcoor(iint).EQ.ct3) then
< C c                  write (26,*) 'RTS',intcoor(iint),ct3
< C                     intcoor(iint)='RTS'
< C                  else if (intcoor(iint).EQ.ct5) then
< C                     intcoor(iint)='AABS1'
< C                  else if (intcoor(iint).EQ.ct7) then
< C                     intcoor(iint)='diBS1'
< C                  else
< C                     continue
< C                  endif
< C                enddo
< C                ct2=atomlabel(isite)(:3)
< C                ct3='RTS'
< C                ct4=atomlabel(jsite)(:3)
< C                ct5='AABS1'
< C                ct6=atomlabel(ksite)(:3)
< C                ct7='diBS1'
< C c               write (26,*) ct1,ct2,ct3,ct4,ct5,ct6,ct7
< C                atomlabel(iatom)=ct1//ct2//ct3//ct4//ct5//ct6//ct7
< C             else
< C                xa=coord(iatom,1)
< C                ya=coord(iatom,2)
< C                za=coord(iatom,3)
< C                xb=coord(ibconn(iatom),1)
< C                yb=coord(ibconn(iatom),2)
< C                zb=coord(ibconn(iatom),3)
< C                xc=coord(iaconn(iatom),1)
< C                yc=coord(iaconn(iatom),2)
< C                zc=coord(iaconn(iatom),3)
< C                xd=coord(idconn(iatom),1)
< C                yd=coord(idconn(iatom),2)
< C                zd=coord(idconn(iatom),3)
< C             endif
< C cadl Uncomment for version without redefinition of connectivity
< C C             xa=coord(iatom,1)
< C C             ya=coord(iatom,2)
< C C             za=coord(iatom,3)
< C C             xb=coord(ibconn(iatom),1)
< C C             yb=coord(ibconn(iatom),2)
< C C             zb=coord(ibconn(iatom),3)
< C C             xc=coord(iaconn(iatom),1)
< C C             yc=coord(iaconn(iatom),2)
< C C             zc=coord(iaconn(iatom),3)
< C C             xd=coord(idconn(iatom),1)
< C C             yd=coord(idconn(iatom),2)
< C C             zd=coord(idconn(iatom),3)
< C             dist=sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb)+
< C      $      (za-zb)*(za-zb))
< C             call xyz_to_zmat(xa,ya,za,xb,yb,zb,
< C      $      xc,yc,zc,xd,yd,zd,ang,dihed)
< C             write (26,*) iatom,dist,ang,dihed
< C             write (59,*) atomlabel(iatom)
< C             xints(iatom+k)=dist
< C             xints(iatom+k+1)=ang
< C c            if (diedro non presente) allora
< C c            sbatti il diedro in fondo
< C             if (intcoor(iatom+k+2)(:2).NE.'di') then
< C                xints(ncoord-ntau1+minus)=dihed
< C                k=k+1
< C                minus=minus+1
< C             else
< C                xints(iatom+k+2)=dihed
< C                k=k+2 
< C             endif
< C          endif
< C       enddo
< 
< cadl Save data in grid_opt.out in order to make it readable to ts_0
<       do iatom=1,natom1
<          write (59,*) atomlabel(iatom)
<       enddo
<       do iint=1,ncoord
<          write(59,*) intcoor(iint),xints(iint)
<       enddo
<       close (unit=59)
< 
< cadl report info in gsm_opt.out
<       write (26,*)
<       do iatom=1,natom1
<          write (26,*) atomlabel(iatom)
<       enddo
<       do iint=1,ncoord
<          write (26,*) intcoor(iint),xints(iint)
<       enddo
< 
<       close (unit=26,status='keep')
< 
<  1201 format ("./geoms/reac1_"I0.2".xyz")
< 
<       return
<       end
< cadl End Modified part
< cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
< 
< 
---
>       
\ No newline at end of file
